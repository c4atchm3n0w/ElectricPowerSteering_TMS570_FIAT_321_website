---
title: TechnicalReference_Asr_NvMs
linkTitle: TechnicalReference_Asr_NvMs
weight: 95
---

<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a>&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/><b>MICROSAR NVM&#160;<br/></b>Technical Reference&#160;<br/>&#160;<br/>&#160;<br/>Version 3.07.00&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>
Authors&#160;<br/>
Manfred Duschinger&#160;<br/>
Status&#160;<br/>
Released&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>
&#160;<br/>
<hr/>
<a name=2></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>1&#160;&#160;Document Information&#160;</b><br/>
<b>1.1&#160;&#160;History&#160;</b><br/>
<b>Author&#160;</b><br/>
<b>Date&#160;</b><br/>
<b>Version&#160;</b><br/>
<b>Remarks&#160;</b><br/>
Christian Kaiser&#160;<br/>
2007-08-20&#160;<br/>
1.4&#160;<br/>
AUTOSAR&#160;2.1,&#160;<br/>
updated for&#160;EAD3.1 usage,&#160;<br/>
conversion to new template &#160;&#160;<br/>
Christian Kaiser&#160;<br/>
2007-12-06&#160;<br/>
3.01.00&#160;<br/>
Change of the document's versioning&#160;<br/>scheme to correspond to the module's&#160;<br/>major and minor,&#160;<br/>
update of parameter description in&#160;<br/>chapter 'Graphical Configuration of&#160;NvM'&#160;<br/>and service&#160;port generation description,&#160;<br/>
remove of DATASET&#160;ROM, feature not&#160;<br/>supported anymore,&#160;<br/>
remove of introduction paragraphs from&#160;<br/>'Description&#160;of Memory&#160;Mapping and&#160;<br/>Compiler&#160;Abstraction', not subject of&#160;this&#160;<br/>document,&#160;<br/>
simplified 'Block Management&#160;Types'&#160;<br/>naming,&#160;<br/>
formal changes &#160; &#160;<br/>
Christian Kaiser&#160;<br/>
2008-01-11&#160;<br/>
3.01.01&#160;<br/>
New chapter to clarify the dependency on&#160;<br/>the CRC library,&#160;<br/>
stated explicitly that DET&#160;is optional,&#160;<br/>
corrected default values&#160;&#160;&#160;<br/>
Manfred Duschinger,&#160;<br/>
2008-05-23&#160;3.02.00&#160;<br/>
AUTOSAR&#160;<br/>
3,&#160;<br/>
Heike Bischof&#160;<br/>
conversion to&#160;Technical&#160;Reference&#160;<br/>
Manfred Duschinger&#160;<br/>
2008-12-08&#160;<br/>
3.03.00&#160;<br/>
ESCAN00027300: Description of&#160;<br/>NvM_ServiceIdType&#160;in&#160;<br/>SingleBlockCallbackFunction and&#160;<br/>MultiBlockCallbackFunction&#160;<br/>
Description&#160;and expected caller context&#160;<br/>of NvM_SetBlockLockStatus-API&#160;<br/>reworked.&#160;<br/>
Chapter 4.4.17 ‘Concurrent access to NV&#160;<br/>data for DCM’&#160;added.&#160;<br/>
Chapter 4.4.5.2: Write order at redundant&#160;<br/>blocks added.&#160;<br/>
Expansion of glossary.&#160;<br/>
Chapter 7.2.2: Description of ‘Dataset&#160;<br/>Selection Bits’&#160;added.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
2&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=3></a>Technical Reference MICROSAR NVM&#160;<br/>
Manfred Duschinger&#160;<br/>
2009-02-25&#160;<br/>
3.03.01&#160;<br/>
ESCAN00031177: Manufacturer specific&#160;<br/>requirements attribute for traceability&#160;<br/>resons&#160;<br/>
Manfred Duschinger&#160;<br/>
2009-03-24&#160;<br/>
3.03.02&#160;<br/>
ESCAN00032480: Missing information in&#160;<br/>documentation:&#160;<br/>
Chapter 6.4.5: ‘Description of&#160;<br/>NvM_RequestResultType added’.&#160;<br/>
Chapters 6.4.15 and 6.4.16: ‘Services are&#160;<br/>multiblock requests’.&#160;<br/>
Manfred Duschinger&#160;<br/>
2009-06-03&#160;<br/>
3.04.00&#160;<br/>
ESCAN00032480: Update of History of&#160;<br/>version 3.03.02: Updated changed&#160;<br/>chapters. &#160;<br/>
Chapter &#160;6.2: ‘Block ID 0&#160;is only allowed&#160;<br/>for API&#160;NvM_GetErrorStatus()’&#160;<br/>
ESCAN00033075: Chapter 4.5.1.1:&#160;<br/>DataIndex Check in NvM_ReadBlock()&#160;<br/>added. DataIndex Check was also added&#160;<br/>to NvM_InvalidateNvBlock() and&#160;<br/>NvM_EraseNvBlock().&#160;<br/>
ESCAN00033900: Chapter 4.4.17:&#160;<br/>“Priority&#160;Handling of DCM-Blocks”&#160;<br/>
ESCAN00035089: Chapters 4.1, 7.2.2&#160;<br/>“Callbacks NvM_JobEndNotification,&#160;<br/>NvM_JobErrorNotification implemented”&#160;<br/>
ESCAN00034073: Chpaters 2, 4.4.5.1,&#160;<br/>7.2.2 “Crc Handling is&#160;configurable:&#160;Either&#160;<br/>an internal buffer is used&#160;or Crc is stored&#160;<br/>at the end of&#160;RAM&#160;Block.”&#160;<br/>
ESCAN00035891: Chapter 7.1.1&#160;<br/>“Integrate SWC-Generation into CFG&#160;<br/>Pro's Generation process”&#160;<br/>
Chapter 3.1: update&#160;AUTOSAR&#160;<br/>architecture figure.&#160;<br/>
Christian Kaiser&#160;<br/>
2010-01-25&#160;<br/>
3.04.01&#160;<br/>
ESCAN00039648 – Rebuilt document;&#160;<br/>made hyperlinks working. Updated Logo;&#160;<br/>No changes in content.&#160;<br/>
Christian Kaiser&#160;<br/>
2010-03-26&#160;<br/>
3.05.00&#160;<br/>
Updated Component history&#160;<br/>
Whole document: “EAD”&#160;Æ&#160;“DaVinci&#160;<br/>Configurator”&#160;<br/>
Added Ch. 7.3 “Attributes only&#160;<br/>configurable&#160;using GCE”&#160;<br/>
Updated Ch. 5.6.1 – “RAM Usage”&#160;<br/>
ESCAN00040662: Chapter 4.4.3:&#160;Added&#160;<br/>note about restricted access to RAM&#160;<br/>block during&#160;job execution.&#160;<br/>
ESCAN00035134: Chapter 5.1.2&#160;<br/>reworked&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
3&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=4></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-4_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
ESCAN00039749: Ch. 4.4.10, 8.2.4:&#160;<br/>Guaranteed CRC&#160;values; Ch 6.4.7: note&#160;<br/>about asynchronous CRC calculation&#160;<br/>
ESCAN00031315: added Ch. 4.2.1, Ch &#160;<br/>
8.2.3; updated Ch. 7.2.5&#160;<br/>
ESCAN00042745 – corrected Ch. 4.5.2&#160;<br/>
Manfred Duschinger&#160;<br/>
2011-01-25&#160;<br/>
3.07.00&#160;<br/>
ESCAN00047171: Ch. 6.4.18:&#160;<br/>NvM_KillWriteAll; Abbreviations:&#160;ECUM&#160;<br/>
ESCAN00045141: Ch. 4.4.5.1:&#160;<br/>information about names of Block&#160;<br/>Handles&#160;<br/>
Table 1-1&#160;&#160;&#160;History&#160;of the&#160;document&#160;<br/>
<b>1.2&#160;&#160;Reference Documents&#160;</b><br/>
<b>No.&#160;</b><br/>
<b>Title&#160;</b><br/>
<b>Version&#160;</b><br/>
[1] &#160;&#160;AUTOSAR_SWS_NVRAMManager.pdf&#160;<br/>
V&#160;2.2.0&#160;<br/>
[2] &#160;&#160;AUTOSAR_SWS_DET.pdf&#160;<br/>
V&#160;2.2.0&#160;<br/>
[3] &#160;&#160;AUTOSAR_SWS_DEM.pdf&#160;<br/>
V&#160;2.2.1&#160;<br/>
[4] &#160;&#160;AUTOSAR_BasicSoftwareModules.pdf&#160;<br/>
V&#160;1.2.0&#160;<br/>
Table 1-2&#160;&#160;&#160;Reference documents&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Please note&#160;<br/></b>We have configured the&#160;programs in accordance&#160;with your specifications in the&#160;<br/>
&#160;&#160;questionnaire. Whereas&#160;the programs do support&#160;other configurations than the one&#160;<br/>
specified&#160;in&#160;your questionnaire, Vector´s release&#160;of the programs delivered to your&#160;<br/>company is&#160;expressly restricted to the&#160;configuration you have&#160;specified in&#160;the&#160;<br/>questionnaire.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
4&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=5></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Contents&#160;</b><br/>
<a href="TechnicalReference_Asr_NvMs.html#2"><b>1</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#2"><b>Document Information....................................................................................................&#160;2</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#2">1.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#2">History...............................................................................................................&#160;2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#4">1.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#4">Reference Documents&#160;......................................................................................&#160;4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#11"><b>2</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#11"><b>Component History.......................................................................................................&#160;11</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#12"><b>3</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#12"><b>Introduction&#160;...................................................................................................................&#160;12</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#13">3.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#13">Architecture&#160;Overview.....................................................................................&#160;13&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15"><b>4</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15"><b>Functional Description&#160;.................................................................................................&#160;15</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">4.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Features..........................................................................................................&#160;15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">4.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Initialization&#160;.....................................................................................................&#160;15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#16">4.2.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#16">Block Size&#160;Checks&#160;..........................................................................................&#160;16&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#17">4.2.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#17">Start-up&#160;...........................................................................................................&#160;17&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#17">4.2.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#17">Initialization&#160;of the Data Blocks&#160;.......................................................................&#160;17&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">4.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">States&#160;..............................................................................................................&#160;18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">4.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">Main Functions&#160;...............................................................................................&#160;18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">4.4.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">Hardware Independence&#160;................................................................................&#160;18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">4.4.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">Synchronous Requests...................................................................................&#160;18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">4.4.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#18">Asynchronous Requests&#160;.................................................................................&#160;18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#19">4.4.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#19">API Configuration Classes and additional&#160;API Services&#160;.................................&#160;19&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#20">4.4.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#20">Block Handling&#160;................................................................................................&#160;20&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#20">4.4.5.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#20">NV Blocks and Block Handles&#160;........................................................................&#160;20&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#21">4.4.5.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#21">Different&#160;Types of NV Blocks&#160;..........................................................................&#160;21&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#22">4.4.5.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#22">Permanent&#160;and non-permanent RAM Blocks&#160;.................................................&#160;22&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">4.4.5.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">ROM Defaults&#160;.................................................................................................&#160;23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">4.4.5.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">Checksum.......................................................................................................&#160;23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">4.4.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">Prioritized or&#160;non-prioritized Queuing of asynchronous Requests..................&#160;23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">4.4.7&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">Asynchronous Job-End&#160;Polling&#160;.......................................................................&#160;23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">4.4.8&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#23">Asynchronous Job-End&#160;Notification&#160;................................................................&#160;23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#24">4.4.9&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#24">Immediate&#160;Priority Jobs and Cancellation of current Jobs..............................&#160;24&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#24">4.4.10&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#24">Asynchronous CRC Calculation&#160;.....................................................................&#160;24&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">4.4.11&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">Write Protection&#160;..............................................................................................&#160;25&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">4.4.12&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">Erase and Invalidate&#160;.......................................................................................&#160;25&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">4.4.13&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">Init Callbacks&#160;..................................................................................................&#160;25&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">4.4.14&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#25">Define Locking/ Unlocking Services&#160;...............................................................&#160;25&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">4.4.15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">Interrupts.........................................................................................................&#160;26&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">4.4.16&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">Data Corruption&#160;..............................................................................................&#160;26&#160;</a><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
5&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=6></a>Technical Reference MICROSAR NVM&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#26">4.4.17&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">Concurrent access&#160;to NV data for DCM..........................................................&#160;26&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">4.4.18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#26">Removed Functionality&#160;...................................................................................&#160;26&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">4.4.19&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">Changed Functionality&#160;....................................................................................&#160;27&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">4.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">Error Handling.................................................................................................&#160;27&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">Development Error Reporting&#160;.........................................................................&#160;27&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#28">4.5.1.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#28">Parameter Checking&#160;.......................................................................................&#160;28&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#29">4.5.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#29">Production Code&#160;Error&#160;Reporting&#160;...................................................................&#160;29&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31"><b>5</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31"><b>Integration&#160;.....................................................................................................................&#160;31</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">5.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">Scope of Delivery............................................................................................&#160;31&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">5.1.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">Static Files&#160;......................................................................................................&#160;31&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">5.1.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">Dynamic Files&#160;.................................................................................................&#160;32&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">5.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">Include Structure.............................................................................................&#160;32&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#33">5.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#33">Compiler&#160;Abstraction and Memory&#160;Mapping&#160;...................................................&#160;33&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">Dependencies on SW Modules&#160;......................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">OSEK /&#160;AUTOSAR OS....................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">DEM&#160;................................................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">DET.................................................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">MEMIF&#160;............................................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">CRC Library&#160;....................................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">5.4.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#34">Callback Functions&#160;.........................................................................................&#160;34&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">5.4.7&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">RTE.................................................................................................................&#160;35&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">5.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">Integration Steps&#160;.............................................................................................&#160;35&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">5.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#35">Estimating Resource Consumption&#160;................................................................&#160;35&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">5.6.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">RAM Usage&#160;....................................................................................................&#160;36&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">5.6.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">ROM Usage&#160;....................................................................................................&#160;36&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">5.6.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#36">NV Usage&#160;.......................................................................................................&#160;36&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38"><b>6</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38"><b>API Description&#160;.............................................................................................................&#160;38</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38">6.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38">Interfaces Overview&#160;........................................................................................&#160;38&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38">6.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#38">Type Definitions&#160;..............................................................................................&#160;38&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">6.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">Global API&#160;Constants......................................................................................&#160;40&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">6.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">Services provided by NVM&#160;.............................................................................&#160;40&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">6.4.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">NvM_Init..........................................................................................................&#160;40&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">6.4.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">NvM_SetDataIndex.........................................................................................&#160;41&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">6.4.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">NvM_GetDataIndex&#160;........................................................................................&#160;41&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">6.4.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">NvM_SetBlockProtection&#160;................................................................................&#160;42&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">6.4.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">NvM_GetErrorStatus.......................................................................................&#160;43&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">6.4.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">NvM_GetVersionInfo.......................................................................................&#160;43&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">6.4.7&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">NvM_SetRamBlockStatus...............................................................................&#160;44&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#45">6.4.8&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#45">NvM_SetBlockLockStatus...............................................................................&#160;45&#160;</a><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
6&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=7></a>Technical Reference MICROSAR NVM&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#46">6.4.9&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#46">NvM_MainFunction&#160;.........................................................................................&#160;46&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#46">6.4.10&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#46">NvM_ReadBlock&#160;.............................................................................................&#160;46&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">6.4.11&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">NvM_WriteBlock&#160;.............................................................................................&#160;47&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#48">6.4.12&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#48">NvM_RestoreBlockDefaults&#160;............................................................................&#160;48&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#49">6.4.13&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#49">NvM_EraseNvBlock&#160;........................................................................................&#160;49&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#50">6.4.14&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#50">NvM_InvalidateNvBlock&#160;..................................................................................&#160;50&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#51">6.4.15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#51">NvM_ReadAll&#160;..................................................................................................&#160;51&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">6.4.16&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">NvM_WriteAll&#160;..................................................................................................&#160;52&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">6.4.17&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">NvM_CancelWriteAll&#160;.......................................................................................&#160;52&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">6.4.18&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">NvM_KillWriteAll&#160;.............................................................................................&#160;53&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">6.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">Services used by NVM&#160;...................................................................................&#160;53&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">6.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">Callback Functions&#160;.........................................................................................&#160;54&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">6.6.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">NvM_JobEndNotification&#160;................................................................................&#160;54&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">6.6.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">NvM_JobErrorNotification&#160;...............................................................................&#160;55&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">6.7&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">Configurable Interfaces...................................................................................&#160;55&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">6.7.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">SingleBlockCallbackFunction&#160;.........................................................................&#160;55&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">6.7.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">MultiBlockCallbackFunction&#160;............................................................................&#160;56&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">6.7.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">InitBlockCallbackFunction...............................................................................&#160;56&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">6.8&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Service Ports&#160;..................................................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">6.8.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Client Server&#160;Interface&#160;....................................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Provide Ports on NVM side.............................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1.1&#160;&#160;PAdmin_&lt;BlockName&gt;&#160;...................................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1.2&#160;&#160;PS_&lt;BlockName&gt;&#160;..........................................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">6.8.1.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">Require Ports&#160;..................................................................................................&#160;58&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">6.8.1.2.1&#160;&#160;NvM_RpNotifyFinished_Id&lt;BlockName&gt;&#160;.......................................................&#160;58&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59"><b>7</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59"><b>Configuration&#160;................................................................................................................&#160;59</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">7.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">Software Component&#160;Template.......................................................................&#160;59&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">7.1.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">Generation&#160;......................................................................................................&#160;59&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#61">7.1.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#61">Import into DaVinci Developer&#160;........................................................................&#160;61&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">7.1.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">Dependencies on Configuration of&#160;NVM&#160;Attributes.........................................&#160;62&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">7.1.3.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">Naming of Service Port Interfaces&#160;..................................................................&#160;62&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">7.1.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#62">Service Port Prototypes&#160;..................................................................................&#160;62&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#63">7.1.4.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#63">Port Prototype Naming&#160;...................................................................................&#160;63&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#63">7.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#63">Configuration of NVM&#160;Attributes&#160;.....................................................................&#160;63&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#64">7.2.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#64">Start configuration of the&#160;NVM&#160;........................................................................&#160;64&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#65">7.2.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#65">General Settings&#160;.............................................................................................&#160;65&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#67">7.2.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#67">Special NVRAM&#160;Blocks...................................................................................&#160;67&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#69">7.2.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#69">User Block&#160;Description&#160;...................................................................................&#160;69&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#76">7.2.5&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#76">Error Detection................................................................................................&#160;76&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">7.2.6&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Module API&#160;.....................................................................................................&#160;78&#160;</a><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
7&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=8></a>Technical Reference MICROSAR NVM&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#78">7.2.6.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Provided API&#160;group&#160;.........................................................................................&#160;78&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">7.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Attributes only configurable using&#160;GCE&#160;..........................................................&#160;78&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80"><b>8</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80"><b>AUTOSAR Standard&#160;Compliance.................................................................................&#160;80</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">Deviations&#160;.......................................................................................................&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">Additions/ Extensions&#160;.....................................................................................&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.2.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">Parameter Checking&#160;.......................................................................................&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.2.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">Concurrent access&#160;to NV data&#160;........................................................................&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.2.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">RAM-/ROM Block&#160;Size&#160;checks&#160;.......................................................................&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">8.2.4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#80">Calculated&#160;CRC&#160;value does not depend on number of calculation steps&#160;.......&#160;80&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#81">8.3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#81">Limitations.......................................................................................................&#160;81&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82"><b>9</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82"><b>Glossary&#160;and&#160;Abbreviations&#160;........................................................................................&#160;82</b>&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82">9.1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82">Glossary..........................................................................................................&#160;82&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#83">9.2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#83">Abbreviations&#160;..................................................................................................&#160;83&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#84"><b>10</b>&#160;&#160;<b>Contact...........................................................................................................................&#160;84</b>&#160;<br/></a>&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
8&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=9></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Illustrations&#160;</b><br/>
<a href="TechnicalReference_Asr_NvMs.html#13">Figure 3-1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#13">AUTOSAR architecture...................................................................................&#160;13&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#14">Figure 3-2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#14">Interfaces to&#160;adjacent modules of the NVM&#160;....................................................&#160;14&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">Figure 5-1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">The file structure of the&#160;NVM sections module&#160;...............................................&#160;32&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">Figure 7-1&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#59">Generate an NVM software component template...........................................&#160;59&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#60">Figure 7-2&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#60">Change target directory for all generated SW-C files of NvM.&#160;........................&#160;60&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#61">Figure 7-3&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#61">Import a new software component into DaVinci Developer&#160;............................&#160;61&#160;</a><br/>
<b>&#160;</b><br/>
<b>Tables&#160;</b><br/>
&#160;&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#4">Table 1-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#4">History of the document&#160;....................................................................................&#160;4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#4">Table 1-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#4">Reference documents.......................................................................................&#160;4&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#11">Table 2-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#11">Component history...........................................................................................11&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Table 4-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Supported SWS features&#160;................................................................................&#160;15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Table 4-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#15">Not supported SWS features&#160;..........................................................................&#160;15&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#22">Table 4-3&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#22">Block concept&#160;.................................................................................................&#160;22&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">Table 4-4&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#27">Mapping of service IDs to services&#160;.................................................................&#160;27&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#28">Table 4-5&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#28">Errors reported to DET&#160;...................................................................................&#160;28&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#29">Table 4-6&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#29">Development Error Checking:&#160;Assignment of checks to&#160;services...................&#160;29&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#30">Table 4-7&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#30">Errors reported to DEM...................................................................................&#160;30&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">Table 5-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#31">Static files........................................................................................................&#160;31&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">Table 5-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#32">Generated files&#160;...............................................................................................&#160;32&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#33">Table 5-3&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#33">Compiler abstraction and memory&#160;mapping&#160;...................................................&#160;33&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#39">Table 6-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#39">Type definitions...............................................................................................&#160;39&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">Table 6-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#40">NvM_Init..........................................................................................................&#160;40&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">Table 6-3&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#41">NvM_SetDataIndex.........................................................................................&#160;41&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">Table 6-4&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">NvM_GetDataIndex&#160;........................................................................................&#160;42&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">Table 6-5&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#42">NvM_SetBlockProtection&#160;................................................................................&#160;42&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">Table 6-6&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#43">NvM_GetErrorStatus.......................................................................................&#160;43&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">Table 6-7&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">NvM_GetVersionInfo.......................................................................................&#160;44&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">Table 6-8&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#44">NvM_SetRamBlockStatus...............................................................................&#160;44&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#45">Table 6-9&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#45">NvM_SetBlockLockStatus...............................................................................&#160;45&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#46">Table 6-10&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#46">NvM_MainFunction.........................................................................................&#160;46&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">Table 6-11&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">NvM_ReadBlock&#160;.............................................................................................&#160;47&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">Table 6-12&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#47">NvM_WriteBlock&#160;.............................................................................................&#160;47&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#48">Table 6-13&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#48">NvM_RestoreBlockDefaults&#160;............................................................................&#160;48&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#49">Table 6-14&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#49">NvM_EraseNvBlock&#160;........................................................................................&#160;49&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#50">Table 6-15&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#50">NvM_InvalidateNvBlock&#160;..................................................................................&#160;50&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#51">Table 6-16&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#51">NvM_ReadAll..................................................................................................&#160;51&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">Table 6-17&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#52">NvM_WriteAll&#160;..................................................................................................&#160;52&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">Table 6-18&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">NvM_CancelWriteAll&#160;.......................................................................................&#160;53&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">Table 6-19&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#53">NvM_KilllWriteAll.............................................................................................&#160;53&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">Table 6-19&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">Services used by the NVM&#160;.............................................................................&#160;54&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">Table 6-20&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#54">NvM_JobEndNotification&#160;................................................................................&#160;54&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">Table 6-21&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#55">NvM_JobErrorNotification&#160;...............................................................................&#160;55&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">Table 6-22&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">SingleBlockCallbackFunction&#160;.........................................................................&#160;56&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">Table 6-23&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#56">MultiBlockCallbackFunction&#160;............................................................................&#160;56&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Table 6-24&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">InitBlockCallbackFunction...............................................................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Table 6-25&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#57">Operations of Port Prototype PAdmin_&lt;BlockName&gt;&#160;....................................&#160;57&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">Table 6-26&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">Operations of Port Prototype PS_&lt;BlockName&gt;&#160;............................................&#160;58&#160;</a><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
9&#160;/&#160;&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=10></a>Technical Reference MICROSAR NVM&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#58">Table 6-27&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#58">Operation of Port prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt;&#160;...........&#160;58&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#66">Table 7-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#66">General Settings&#160;.............................................................................................&#160;66&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#69">Table 7-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#69">Special NVRAM blocks&#160;...................................................................................&#160;69&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#75">Table 7-3&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#75">User block description&#160;....................................................................................&#160;75&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Table 7-4&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Error Detection................................................................................................&#160;78&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Table 7-5&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#78">Provided API&#160;...................................................................................................&#160;78&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82">Table 9-1&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#82">Glossary..........................................................................................................&#160;82&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#83">Table 9-2&#160;&#160;</a><br/>
<a href="TechnicalReference_Asr_NvMs.html#83">Abbreviations&#160;..................................................................................................&#160;83&#160;</a><br/>
&#160;<br/>&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
10&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=11></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>2&#160;&#160;Component History&#160;</b><br/>
<b>Component&#160;</b><br/>
<b>New&#160;Features&#160;</b><br/>
<b>Version&#160;</b><br/>
3.05.xx&#160;<br/>
Calculated&#160;CRC32&#160;value does not depend anymore on configuration of&#160;<br/>parameter NvmCrcNumOfBytes.&#160;<br/>
Added RAM and ROM block size checks:&#160;The NvM can be configured to&#160;<br/>check each&#160;RAM block’s and/or each&#160;ROM block’s size against the configured&#160;<br/>NV block length, considering CRC setting, internal buffering,&#160;etc.&#160;<br/>
3.04.xx&#160;<br/>
Crc Handling is configurable: Either&#160;the internal&#160;buffer, available since&#160;<br/>component version 3.02, is used or&#160;Crc is stored at the end&#160;of RAM Block.&#160;<br/>
3.03.xx&#160;<br/>
At processing&#160;a redundant NVRAM&#160;Block NvM&#160;determines an appropriate&#160;<br/>write order, depending on the NV Block’s current state/content.&#160;A&#160;defect&#160;NV&#160;<br/>block is written in preference to a valid one.&#160;<br/>
NVM provides possibility for DCM to access NV data concurrently with NVM’s&#160;<br/>applications.&#160;<br/>
3.02.xx&#160;<br/>
Update to&#160;AUTOSAR 3 specification.&#160;<br/>
Additional API&#160;NvM_SetBlockLockStatus.&#160;<br/>
Storing each NVRAM block’s CRC internally: RAM Blocks provided by the&#160;<br/>application&#160;don’t have to allocate additional space for CRC.&#160;<br/>
Configurability, whether the NVM shall create the&#160;RAM&#160;Block associated&#160;with&#160;<br/>the ConfigID NVRAM Block on its own, or the user creates the RAM block.&#160;<br/>
Table 2-1&#160;&#160;&#160;Component history&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
11&#160;/&#160;84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=12></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-12_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>3&#160;&#160;Introduction&#160;</b><br/>
This document describes the functionality,&#160;API and configuration&#160;of the&#160;AUTOSAR BSW&#160;<br/>module NVM&#160;<a href="TechnicalReference_Asr_NvMs.html#4">as specified in&#160;[1]</a>. &#160;<br/>
&#160;<br/>
<b>Supported AUTOSAR&#160;Release<a href="TechnicalReference_Asr_NvMs.html#12">*</a></b><b>:&#160;</b><br/>
3&#160;<br/>
<b>Supported Configuration Variants:&#160;</b><br/>
link-time&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
<b>Vendor ID:&#160;</b><br/>
NVM_VENDOR_ID&#160;30&#160;<br/>
decimal&#160;<br/>
(= Vector-Informatik,&#160;<br/>according to&#160;HIS)&#160;<br/>
<b>Module ID:&#160;</b><br/>
NVM_MODULE_ID &#160;&#160;<br/>
20 decimal&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#4">(according to ref.&#160;[4])&#160;</a><br/>
* For the precise&#160;AUTOSAR Release 3.x please&#160;see&#160;the release&#160;specific&#160;documentation. &#160;<br/>&#160;<br/>
The module NVM is&#160;created to&#160;abstract the&#160;usage of non-volatile memory, such as&#160;<br/>EEPROM or Flash, from application.&#160;All access&#160;to NV memory is block based.&#160;To&#160;avoid&#160;<br/>conflicts and inconsistent data the NVM shall be the only module to access non-volatile&#160;<br/>memory.&#160;<br/>
The NVM accesses the module MEMIF (Memory&#160;Abstraction Interface) which abstracts&#160;<br/>the modules&#160;FEE (Flash EEPROM Emulation)&#160;and EA&#160;(EEPROM&#160;Abstraction).&#160;Thus, the&#160;<br/>NVM is hardware independent.&#160;The modules FEE&#160;and EA&#160;abstract the access to Flash or&#160;<br/>EEPROM driver.&#160;To&#160;select the&#160;appropriate device (FEE or EA) the NVM uses a handle that&#160;<br/>is provided by the MEMIF.&#160;&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>MICROSAR FEE and MICROSAR&#160;EA&#160;are different products&#160;that are not&#160;part of&#160;<br/>
&#160;&#160;MICROSAR&#160;NVM!&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
12&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=13></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-13_1.jpg"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-13_2.jpg"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-13_3.jpg"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-13_4.jpg"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>3.1&#160;&#160;Architecture Overview&#160;</b><br/>
The following figure shows where the NVM is&#160;located in the&#160;AUTOSAR architecture.&#160;<br/>
&#160;<br/>
Figure 3-1&#160;&#160;AUTOSAR architecture&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
13&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=14></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-14_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
&#160;<br/>
The next figure shows the interfaces&#160;to adjacent modules of the NVM.&#160;&#160;These interfaces&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#38">are described in chapter&#160;6</a>. &#160;<br/>
&#160;<br/>
Figure 3-2&#160;&#160;Interfaces to adjacent modules of the NVM&#160;<br/>
Applications normally do not access the services of the BSW modules directly.&#160;They use&#160;<br/>the service ports provided by the BSW modules via the RTE.&#160;The service ports provided&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#57">by the NVM are listed in chapter&#160;6.8</a><a href="TechnicalReference_Asr_NvMs.html#4">&#160;and are defined in&#160;[1]</a>.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
14&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=15></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>4&#160;&#160;Functional Description&#160;</b><br/>
<b>4.1&#160;&#160;Features&#160;</b><br/>
The features listed in this chapter cover the complete functionality<a href="TechnicalReference_Asr_NvMs.html#4">&#160;specified in&#160;[1].&#160;</a><br/>
The &#34;supported&#34; and &#34;not supported&#34; features are presented&#160;in&#160;the following two tables.&#160;<br/>For further information on not suppor<a href="TechnicalReference_Asr_NvMs.html#80">ted features also see chapter&#160;8</a>.&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#4">The following features described in&#160;[1]</a>&#160;are supported:&#160;<br/>
<b>Supported Feature&#160;</b><br/>
Complete API&#160;<br/>
Block Management&#160;Types (Native, Redundant, Dataset)&#160;<br/>
CRC handling (CRC16,&#160;CRC32)&#160;<br/>
Priority handling, including Immediate (Crash) Data write&#160;<br/>
Job queuing&#160;<br/>
ROM defaults&#160;(ROM defaults&#160;block, Init callback)&#160;<br/>
Config Id handling&#160;<br/>
RAM block valid/modified handling&#160;<br/>
Re-Validation of RAM blocks during&#160;start up using CRC&#160;<br/>
Job end notifications&#160;<br/>
Skipping Blocks during&#160;Start-Up&#160;<br/>
API Configuration Classes&#160;<br/>
Service Ports – Generation of Software Component Description&#160;<br/>
Concurrent access&#160;to NV data for DCM&#160;<br/>
Table 4-1&#160;&#160;&#160;Supported SWS&#160;features&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#4">The following features described in&#160;[1]</a>&#160;are not supported:&#160;<br/>
<b>Not Supported Feature&#160;</b><br/>
Dataset ROM blocks (Management&#160;Type Dataset, multiple&#160;ROM blocks)&#160;<br/>
Disabling Set/Get_DataIndex&#160;API&#160;<br/>
Table 4-2&#160;&#160;&#160;Not supported SWS features&#160;<br/>
<b>4.2&#160;&#160;Initialization&#160;</b><br/>
Before the module NVM can be used it has&#160;to&#160;be initialized.&#160;All modules on which the NVM&#160;<br/>depends&#160;need to be initialized before.&#160;The initialization&#160;of all these modules should be&#160;<br/>done by the ECU State Manager. If the NVM is&#160;not used in an&#160;AUTOSAR environment it&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
15&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=16></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-16_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-16_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
should be done by a different entity.&#160;Pay attention that the NVM&#160;<b>will not</b>&#160;initialize the used&#160;<br/>modules by&#160;its own.&#160;<br/>
Depending on the configuration of the NVM stack, different modules might need to be&#160;<br/>initialized. It is advised to use a bottom up strategy for initialization:&#160;<br/>
&#160;&#160;NV&#160;device drivers for internal devices (FLS/EEP)&#160;<br/>
&#160;&#160;Low level driver that an&#160;external NV device driver&#160;might depend on (e.g. DIO, SPI)&#160;<br/>
&#160;&#160;Drivers for external NV devices&#160;(e.g. external EEP&#160;or FLS)&#160;<br/>
&#160;&#160;NV&#160;device abstraction modules (EA/FEE)&#160;<br/>
&#160;&#160;Non-Volatile Manager&#160;(NVM).&#160;The NVM “initialization” is twofold:&#160;NvM_Init()&#160;and&#160;<br/>
NvM_ReadAll().&#160;NvM_ReadAll()&#160;needs to be the last initialization step!&#160;<br/>
Initializing the modules in this&#160;sequence ensures that as soon&#160;as&#160;a module is used, the&#160;<br/>modules it depends on are ready.&#160;<br/>
<b>4.2.1&#160;</b><br/>
<b>Block Size Checks&#160;</b><br/>
In Development Mode the NvM can be configured&#160;to check the size of every configured&#160;<br/>NVRAM block’s permanent RAM block&#160;as well&#160;as&#160;its ROM&#160;block. It compares the&#160;<br/>configured NVRAM block length to the sizes&#160;of the RAM block and/or ROM block symbols.&#160;<br/>
If the check fails on one NVRAM block, an error is reported to the DET,&#160;and the NvM&#160;<br/>remains uninitialized.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info</b>.&#160;<br/>
If “Development Error&#160;Detection” is enabled, the RAM/ROM block length checks&#160;will&#160;<br/>
&#160;&#160;always be generated into NvM_Cfg.c (NvM_CfgCheckRomBlockLengths&#160;and&#160;<br/>
NvM_CfgCheckRamBlockLengths), and NvM_Init will always call them from&#160;NvM_Init.&#160;<br/>
If RAM and/or ROM block checking&#160;was disabled, the corresponding function will be&#160;<br/>generated to always report “check&#160;passed” to the NvM. Hence these checks can be&#160;<br/>configured at link-time.&#160;<br/>
Since the functions are “implemented” in generated NvM_Cfg.c, they can be debugged,&#160;<br/>even if NvM&#160;was delivered as library. Both checks always iterate over all configured&#160;<br/>blocks,&#160;i.e. they don’t abort upon a detected mismatch.&#160;Accordingly the NVM always&#160;<br/>performs both checks, and then aborts in case of detected mismatch.&#160;This allows you&#160;<br/>to easily detect all mismatching RAM block lengths.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>The NVM&#160;makes use of&#160;the&#160;sizeof&#160;operator.&#160;Therefore your ROM block&#160;and permanent&#160;<br/>
<b>&#160;&#160;</b>RAM block symbols must be declared in the header files using&#160;complete types.&#160;<br/>
Especially declarations like that are not allowed:&#160;<br/>
&#160;&#160;Arrays&#160;of unknown size ([])&#160;<br/>
&#160;&#160;Structures of&#160;unknown contents (struct x;)&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
16&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=17></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-17_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info&#160;<br/></b>By&#160;default the NvM&#160;performs strict checks, i.e. all&#160;sizes must exactly&#160;match. While too&#160;<br/>
&#160;&#160;small RAM&#160;blocks usually will cause&#160;serious issues because&#160;the NVM would overwrite&#160;<br/>
other SW’s&#160;RAM,&#160;you would observe “loss of data” if they are too large,&#160;The NVM&#160;would&#160;<br/>read/write only parts of your data to&#160;NVM&#160;memory.&#160;<br/>
A&#160;common reason is given by CPU’s&#160;alignment requirements: compilers&#160;may enlarge&#160;<br/>structures by&#160;adding padding bytes in order to align its structures on adequate&#160;<br/>boundaries.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>4.2.2&#160;</b><br/>
<b>Start-up&#160;</b><br/>
The basic initialization of the NVRAM Manager is done by the request&#160;NvM_Init().&#160;It&#160;<br/>shall be invoked e.g. by the&#160;ECU State Manager exclusively.&#160;Due to strong constraints&#160;<br/>concerning the ECU start-up time the&#160;NvM_Init()&#160;request does not contain the basic&#160;<br/>initialization of&#160;the configured NVRAM blocks.&#160;The&#160;NvM_Init()&#160;request resets&#160;the&#160;<br/>internal variables of the NVM such&#160;as the queue and the state machine.&#160;<br/>
<b>4.2.3&#160;</b><br/>
<b>Initialization of the Data Blocks&#160;</b><br/>
The initialization of the single blocks is normally also initiated by the ECU State Manager&#160;<br/>by calling&#160;NvM_ReadAll().&#160;All blocks that have no valid RAM data any more and have&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#69">'Select for ReadAll' (see chapter &#160;7.2.4</a>) set will be reloaded from NV&#160;memory or from ROM&#160;<br/>(if available).&#160;<br/>
Block 1 (the configuration ID) has a special role. It is stored in NV memory and also as a&#160;<br/>constant (NvM_CompiledConfigId_t) that is externally&#160;visible and link-time&#160;<br/>configurable. During&#160;NvM_ReadAll()&#160;the NV value of block 1 is compared against the&#160;<br/>constant&#160;NvM_CompiledConfigId_t. In case of a match all&#160;NV blocks are presumed to&#160;<br/>be valid and NvM tries to read them from NV&#160;memory. In case of a mismatch or if the&#160;<br/>configuration ID cannot be read&#160;the system behaves as&#160;following:&#160;<br/>
&#160;&#160;If the configuration switch 'Dynamic&#160;Configuration Handling' (see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#65">7.2.2) is 'OFF',&#160;</a><br/>
the mismatch is ignored. It will be tried to read all blocks from NV&#160;memory (also called&#160;<br/>‘normal runtime preparation’).&#160;<br/>
&#160;&#160;If the 'Dynamic Configuration Handling' is&#160;'ON', the normal runtime preparation is&#160;<br/>
processed for all blocks having been configured with the option 'Resistant to Changed&#160;<br/>SW'. For all other blocks an 'extended runtime preparation' will take place.&#160;<br/>
&#160;&#160;All blocks that will be processed with the 'extended&#160;runtime preparation' will be treated&#160;<br/>
as invalid or blank.&#160;Thus, it is possible to&#160;rewrite a block having been marked as 'Write&#160;<br/>Once'. If available, ROM defaults&#160;are loaded or the initialization callback is invoked.&#160;<br/>
Non-permanent RAM blocks, dataset blocks or&#160;blocks that are&#160;not selected for 'ReadAll'&#160;<br/>(configuration option) are skipped.&#160;They must be loaded manually by the application by&#160;<br/>calling&#160;NvM_ReadBlock().&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
17&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=18></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>4.3&#160;&#160;States&#160;</b><br/>
The NVRAM Manager is internally organized with a state machine which is shown in the&#160;<br/>following chapters.&#160;<br/>
<b>4.4&#160;&#160;Main Functions&#160;</b><br/>
<b>4.4.1&#160;</b><br/>
<b>Hardware Independence&#160;</b><br/>
The NVRAM Manager is independent&#160;from its underlying memory hardware. It accesses&#160;<br/>the&#160;API of the MEMIF (Memory&#160;Abstraction Interface).&#160;The MEMIF abstracts the modules&#160;<br/>FEE (Flash&#160;EEPROM&#160;Emulation) and EA&#160;(EEPROM&#160;Abstraction) for the NVM. FEE and&#160;<br/>EA&#160;are used for storing data blocks in Flash&#160;or EEPROM&#160;devices. For selecting at which&#160;<br/>FEE or EA&#160;instance a block shall be stored, the NVM uses a&#160;device handle (device ID) that&#160;<br/>is provided by the MEMIF.&#160;<br/>
<b>4.4.2&#160;</b><br/>
<b>Synchronous Requests&#160;</b><br/>
The NVM&#160;API services are divided into&#160;synchronous and asynchronous requests. &#160;<br/>
The synchronous services are executed immediately when called.&#160;They are executed in&#160;<br/>the context of the calling task.&#160;This means,&#160;that behavior depends&#160;on the characteristics of&#160;<br/>the calling task and not on the NVM.&#160;For example, if the calling&#160;task is a non-preemptive&#160;<br/>one, the synchronous NVM request&#160;will be executed&#160;until it has&#160;finished. Otherwise, if the&#160;<br/>calling task is a preemptive one, the synchronous NVM request can be preempted by&#160;<br/>another higher prioritized task.&#160;<br/>
Following NVM&#160;API services initiate synchronous requests:&#160;<br/>
&#160;&#160;NvM_Init()&#160;<br/>
&#160;&#160;NvM_SetDataIndex()&#160;<br/>
&#160;&#160;NvM_GetDataIndex()&#160;<br/>
&#160;&#160;NvM_SetBlockProtection()&#160;<br/>
&#160;&#160;NvM_SetBlockLockStatus()&#160;<br/>
&#160;&#160;NvM_SetRamBlockStatus()&#160;(for not CRC protected blocks)&#160;<br/>
&#160;&#160;NvM_GetErrorStatus()&#160;<br/>
&#160;&#160;NvM_GetVersionInfo()&#160;<br/>
<b>4.4.3&#160;</b><br/>
<b>Asynchronous Requests&#160;</b><br/>
Following NVM&#160;API services initiate asynchronous requests:&#160;<br/>
&#160;&#160;NvM_ReadBlock()&#160;<br/>
&#160;&#160;NvM_WriteBlock()&#160;<br/>
&#160;&#160;NvM_RestoreBlockDefaults()&#160;<br/>
&#160;&#160;NvM_EraseNvBlock()&#160;<br/>
&#160;&#160;NvM_InvalidateNvBlock()&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
18&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=19></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-19_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
&#160;&#160;NvM_SetRamBlockStatus()&#160;(for CRC protected blocks)&#160;<br/>
&#160;&#160;NvM_ReadAll()&#160;<br/>
&#160;&#160;NvM_WriteAll()&#160;<br/>
&#160;&#160;NvM_CancelWriteAll()&#160;<br/>
The&#160;API call is handled&#160;in the context of the calling task. Here the service is queued and&#160;<br/>will be processed asynchronously.&#160;The processing of the queued requests is done in the&#160;<br/>context of the caller of the cyclic function&#160;NvM_MainFunction().&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>RAM blocks must not be accessed by&#160;any user&#160;while a request to its associated&#160;<br/>
<b>&#160;&#160;</b>NVRAM Block is pending!&#160;<br/>
There are some exceptions to this&#160;limitation:&#160;<br/>
&#160;&#160;NvM_InvalidateNvBlock and NvM_EraseNvBlock don’t&#160;access any&#160;RAM blocks.&#160;Thus&#160;<br/>
access is&#160;still possible&#160;without limitations&#160;<br/>
&#160;&#160;While the&#160;NvM processes&#160;an NvM_WriteBlock&#160;request, the RAM block may still read.&#160;<br/>
&#160;&#160;Though applications&#160;are not expected to&#160;be running while NvM&#160;processes&#160;NvM_WriteAll,&#160;<br/>
RAM blocks&#160;may be read, as during&#160;NvM_WriteBlock processing.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>4.4.4&#160;</b><br/>
<b>API Configuration Classes and additional&#160;API Services&#160;</b><br/>
Depending on the needs of&#160;the customer, the extent of the NVM can&#160;be tailored.&#160;Three&#160;<br/>configuration classes are specified that offer a different amount&#160;of functionality/functions of&#160;<br/>the NVM:&#160;<br/>
<b>API configuration class 1:&#160;</b><br/>
A&#160;minimum set of&#160;API services is&#160;used.&#160;Queuing and Job prioritization are not&#160;<br/>implemented. Following functions are available:&#160;<br/>
&#160;&#160;NvM_Init()&#160;<br/>
&#160;&#160;NvM_GetErrorStatus()&#160;<br/>
&#160;&#160;NvM_SetRamBlockStatus()&#160;<br/>
&#160;&#160;NvM_ReadAll()&#160;<br/>
&#160;&#160;NvM_WriteAll()&#160;<br/>
&#160;&#160;NvM_CancelWriteAll()&#160;<br/>
<b>API configuration class 2:&#160;</b><br/>
Intermediate set of&#160;API services. Queuing and&#160;job prioritization are implemented. Following&#160;<br/>functions are available additionally according to&#160;API configuration class 1:&#160;<br/>
&#160;&#160;NvM_SetDataIndex()&#160;<br/>
&#160;&#160;NvM_GetDataIndex()&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
19&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=20></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-20_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
&#160;&#160;NvM_ReadBlock()&#160;<br/>
&#160;&#160;NvM_WriteBlock()&#160;<br/>
&#160;&#160;NvM_RestoreBlockDefaults()&#160;<br/>
<b>API configuration class 3:&#160;</b><br/>
All&#160;API services are available. Following&#160;functions&#160;can be used additionally to&#160;API&#160;<br/>configuration class 2:&#160;<br/>
&#160;&#160;NvM_SetBlockProtection()&#160;<br/>
&#160;&#160;NvM_EraseNvBlock()&#160;<br/>
&#160;&#160;NvM_InvalidateNvBlock()&#160;<br/>
The functions&#160;NvM_SetRamBlockStatus()&#160;and&#160;NvM_GetVersionInfo()&#160;can be&#160;<br/>enabled/disabled additionally&#160;via the Configuration tool.&#160;The function&#160;<br/>NvM_SetBlockLockStatus()&#160;&#160;is always&#160;available independent of&#160;API configuration&#160;<br/>class.&#160;<br/>
<b>4.4.5&#160;</b><br/>
<b>Block Handling&#160;</b><br/>
<b>4.4.5.1&#160;&#160;NV Blocks and Block Handles&#160;</b><br/>
Every application's data&#160;packet that is intended for storage in&#160;NV memory is seen as a&#160;<br/>block. For each block&#160;a unique block handle (block ID) is used. For the application the&#160;<br/>(RAM) block is just one of its variables associated with the block.&#160;To&#160;write this variable to&#160;<br/>NV memory it calls the&#160;NvM_WriteBlock()&#160;service with the block handle that is mapped&#160;<br/>to this variable.&#160;The block handle names are given during configuration of the NVM.&#160;They&#160;<br/>are published to the application by including&#160;NvM.h.&#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info&#160;<br/></b>The block handle names are automatically prefixed by the&#160;module short name followed&#160;<br/>
&#160;&#160;by an underscore (NvM_).&#160;The prefixing has no influence on&#160;RTE.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
&#160;<br/>&#160;<br/>
The application only needs to provide space&#160;for CRC storage in its RAM block(s) when&#160;<br/>“Internal Buffer for Crc Handling” is disabled (see c<a href="TechnicalReference_Asr_NvMs.html#65">hapter&#160;7.2.2</a>). Is the internal buffer&#160;<br/>enabled, no additional&#160;space for CRC storage in&#160;the RAM block(s) is necessary.&#160;The NVM&#160;<br/>copies in this case the data not directly from the application variable to the NV memory.&#160;<br/>There is an extra buffering within the module NVM, because the NVM writes data and&#160;<br/>CRC, if configured,&#160;within&#160;one&#160;request to the NV memory. CRC is not stored in&#160;the&#160;<br/>application variable; it is stored in an internal variable by&#160;the NVM. Before processing write&#160;<br/>request to underlying components,&#160;the NVM copies data and CRC into the internal buffer.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
20&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=21></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-21_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>The actual processing&#160;of&#160;an asynchronous job (such as a write job) is done in&#160;<br/>
&#160;&#160;NvM_MainFunction.&#160;Therefore it needs to be called cyclically. Usually this is done by&#160;<br/>
the Basic Software Scheduler (SCHM).&#160;<br/>
<b>&#160;</b><br/>
<b>4.4.5.2&#160;&#160;Different Types of NV Blocks&#160;</b><br/>
The application data can be stored in different types of&#160;blocks in the NV memory.&#160;<br/>
<b>Native Block:&#160;</b><br/>
This is the standard block type.&#160;The&#160;data is stored once in the NV area.&#160;<br/>
<b>Redundant Block:&#160;</b><br/>
The data is&#160;stored twice in the NV area.&#160;A&#160;read request is successful even if&#160;one block is&#160;<br/>corrupted but the other block&#160;could be read.&#160;An erase or&#160;invalidate request is only&#160;<br/>successful if both blocks could be&#160;erased respectively invalidated. &#160;<br/>
If the NVM detects&#160;a defect NV Block, it is&#160;written in preference to a valid NV Block. If&#160;<br/>writing to one single NV Block&#160;failed, the NVM reports the error NVM_E_REQ_FAILED&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#29">(see chapter&#160;4.5.2</a>) to&#160;the DEM. If writing to primary NV&#160;block failed, NVM ends the request&#160;<br/>always with a negative job result. If the primary NV block was written successfully, the&#160;<br/>request always ends with a positive job result, even when the secondary NV block failed.&#160;<br/>
<b>Dataset Blocks:&#160;</b><br/>
A&#160;dataset block can be seen as an array.&#160;A&#160;configurable number of instances of this block&#160;<br/>are stored in NV-memory. In the RAM area there is only one RAM&#160;buffer.&#160;The appropriate&#160;<br/>NV block instance is selected by the so called “data index”.&#160;The data index can be read&#160;<br/>and set by synchronous&#160;API&#160;services&#160;NvM_GetDataIndex()&#160;and&#160;<br/>NVM_SetDataIndex().&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
21&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=22></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-22_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Concept&#160;</b><br/>
<b>Description&#160;</b><br/>
Block&#160;<br/>
General notion of the structure composed of data, state and&#160;CRC. It is&#160;<br/>spread over RAM,&#160;ROM,&#160;NVRAM&#160;<br/>
NV Block&#160;<br/>
One block in&#160;NVRAM - CRC is optional.&#160;<br/>
NV Block of&#160;<br/>
One NV Block of specified type&#160;<br/>
&#160;&#160;Native type&#160;<br/>
&#160;&#160;Redundant type&#160;<br/>
&#160;&#160;Dataset type&#160;<br/>
RAM&#160;Block&#160;<br/>
One data Block in RAM.&#160;The data is&#160;shared by NVRAM Manager and&#160;<br/>application.&#160;E. g. application writes data to this block and requests&#160;<br/>NVRAM&#160;Manager to write it into NVRAM.&#160;<br/>
ROM Block&#160;<br/>
One data block in ROM. Default data supplied by&#160;application.&#160;<br/>
NVRAM Block&#160;<br/>
A&#160;logical&#160;composition of&#160;one RAM block and its&#160;corresponding NV and&#160;<br/>ROM&#160;Block.&#160;<br/>
NV = NVRAM&#160;<br/>
Non-volatile memory.&#160;Actually a synonym for Flash or EEPROM devices.&#160;<br/>
Table 4-3&#160;&#160;&#160;Block concept&#160;<br/>
<b>4.4.5.3&#160;&#160;Permanent&#160;and non-permanent RAM Blocks&#160;</b><br/>
The RAM block (application&#160;variable) can be either permanent or non-permanent.&#160;A&#160;<br/>permanent RAM block&#160;belongs to a NV block that&#160;is accessed only by one application.&#160;The&#160;<br/>address of the RAM block is fix and is stored in the configuration of the NVM.&#160;<br/>
It is also possible to have multiple applications accessing the same NV block. Each&#160;<br/>application uses its own RAM block. In this&#160;case the RAM block&#160;is called non-permanent.&#160;<br/>As the RAM address is not stored (and may&#160;vary) a pointer must be given for reading and&#160;<br/>writing a non-permanent block.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Asynchronous&#160;API functions can be reentered by different tasks. So it is possible that&#160;<br/>
&#160;&#160;several tasks queue for&#160;example a&#160;write job at the same time (a task with higher priority&#160;<br/>
might interrupt a lower one). But it is&#160;not possible&#160;to queue the same block multiple&#160;<br/>times (neither by different tasks nor&#160;for different jobs). So if for instance&#160;a read job for&#160;<br/>block 5 is queued, an erase job for this block can’t be queued before the&#160;read job is&#160;<br/>finished.&#160;<br/>
If one block&#160;is used by&#160;multiple tasks,&#160;which is a&#160;common task for non-permanent RAM&#160;<br/>blocks,&#160;the&#160;application&#160;is&#160;responsible for synchronization. Of course if, for example,&#160;an&#160;<br/>erase request is in&#160;process the RAM block could be read or written without any effect to&#160;<br/>the result of&#160;the erase job.&#160;The only problem is that the NVM does not offer any&#160;<br/>information to an application what service is currently processed for a block.&#160;The&#160;<br/>application&#160;that initiated&#160;the service&#160;of course does know, but&#160;a different application&#160;that&#160;<br/>also uses&#160;the block does not. So the safest way for block access is not to use the RAM&#160;<br/>block as long as it is “pending”.&#160;This&#160;way RAM inconsistency can be avoided&#160;<br/>definitively.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
22&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=23></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>4.4.5.4&#160;&#160;ROM Defaults&#160;</b><br/>
ROM defaults can be assigned to any NVRAM block.&#160;The ROM defaults block is provided&#160;<br/>by the application.&#160;Alternatively,&#160;an init callback can be used.&#160;These features are selected&#160;<br/>during configuration. It is only&#160;possible to configure either ROM&#160;defaults or an init callback&#160;<br/>for a block.&#160;<br/>
ROM defaults can be read explicit (by a call of&#160;NvM_RestoreBlockDefaults()). ROM&#160;<br/>defaults&#160;will also&#160;be read implicitly during a read request,&#160;if no valid&#160;data could be read&#160;<br/>from NV-memory,&#160;either due&#160;to a CRC error or because of&#160;a failure reported by the&#160;<br/>underlying MemHwA&#160;via MemIf.&#160;<br/>
<b>4.4.5.5&#160;&#160;Checksum&#160;</b><br/>
For each block an optional checksum can be configured.&#160;This checksum can be either&#160;<br/>CRC16 or CRC32.&#160;The checksum is&#160;stored&#160;directly after the block data in the NV memory.&#160;<br/>In RAM, CRC is not stored after the block data;&#160;it is stored in an internal variable. NVM&#160;<br/>does not copy the data directly from the application variable to the NV&#160;memory.&#160;There is an&#160;<br/>extra buffering within the module NVM, because it writes&#160;data&#160;and&#160;CRC with one request&#160;<br/>to the NV memory.&#160;Thus an application does not need to&#160;provide any space for NvM’s&#160;<br/>checksum at the end of a RAM block.&#160;<br/>
<b>4.4.6&#160;</b><br/>
<b>Prioritized or non-prioritized Queuing of asynchronous Requests&#160;</b><br/>
As mentioned before, asynchronous services are not processed immediately but queued&#160;<br/>and processed asynchronously&#160;by the&#160;NvM_MainFunction().&#160;This is necessary to&#160;<br/>decrease the runtime of&#160;application tasks and to increase the predictability of their duration&#160;<br/>(synchronous write jobs on an&#160;EEPROM or Flash would block&#160;your task for multiple&#160;<br/>milliseconds up to one second). &#160;<br/>
Jobs can be queued either&#160;prioritized or&#160;non-prioritized, depending on the user&#160;<br/>configuration. &#160;<br/>
If job prioritization is&#160;configured, the priorities 0 (immediate priority) until 255 (lowest&#160;<br/>priority) can be selected for a block. It is important that the priority depends on the block,&#160;<br/>rather than the request. Multi&#160;block requests&#160;always have a priority value greater than 255,&#160;<br/>i.e. their priority is less&#160;than the lowest block specific priority; they will be processed after&#160;<br/>all single block requests have been completed.&#160;<br/>
If block prioritization is not selected,&#160;the job queue works&#160;as a FIFO buffer.&#160;<br/>
<b>4.4.7&#160;</b><br/>
<b>Asynchronous Job-End Polling&#160;</b><br/>
As alluded before, asynchronous requests&#160;are processed in the background.&#160;The&#160;<br/>application&#160;has the possibility to poll the&#160;NVM for the end of the service by calling&#160;<br/>NvM_GetErrorStatus().&#160;&#160;NVM_REQ_PENDING&#160;will be returned as long&#160;as the job is&#160;<br/>queued or in process.&#160;Once the job is finished&#160;NvM_GetErrorStatus()&#160;will return the&#160;<br/>job result.&#160;<br/>
<b>4.4.8&#160;</b><br/>
<b>Asynchronous Job-End Notification&#160;</b><br/>
Alternatively to poll for the job-end, a&#160;job-end notification can be implemented and&#160;<br/>configured for every block.&#160;It will be called by the NVM every time a job is finished.&#160;<br/>Finished means: Job finished either&#160;successfully or cancelled.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
23&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=24></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-24_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-24_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>4.4.9&#160;</b><br/>
<b>Immediate&#160;Priority&#160;Jobs and Cancellation of current Jobs&#160;</b><br/>
If job prioritization is selected,&#160;blocks of different priority&#160;exist.&#160;A&#160;new queued, higher prior&#160;<br/>job, (e.g. priority 5) does not cancel/suspend a lower prioritized job (e.g. priority 10) if this&#160;<br/>job is already processed.&#160;<br/>
The only exceptions for this&#160;are immediate priority jobs (priority 0) which&#160;can suspend a&#160;<br/>running job that priority is&#160;less.&#160;The suspended job will be restarted after all jobs with&#160;<br/>higher priority are finished.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay&#160;attention that only&#160;blocks with high priority&#160;(0) can be erased (by&#160;using&#160;API&#160;<br/>
&#160;&#160;NvM_EraseNvBlock())!&#160;<br/>
<b>&#160;</b><br/>
<b>4.4.10&#160;&#160;Asynchronous CRC Calculation&#160;</b><br/>
The (re-)calculation&#160;of a block's&#160;CRC is done&#160;asynchronously by the&#160;<br/>NvM_MainFunction().&#160;A&#160;CRC protected block's CRC value is calculated every time the&#160;<br/>block shall be written to NV memory. If a block is read from NV memory the CRC value&#160;is&#160;<br/>recalculated and compared to the one that was just read from NV&#160;memory.&#160;<br/>
If&#160;NvM_SetRamBlockStatus(TRUE)&#160;is called, the calculation of the CRC value over the&#160;<br/>RAM block’s data is also initiated, unless the configuration option&#160;'Calculate RAM CRC'&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#69">(see chapter &#160;7.2.4</a>) was disabled for this block.&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>The purpose of requesting recalculation of the RAM CRC with every call to&#160;<br/>
&#160;&#160;NvM_SetRamBlockStatus&#160;is to provide the possibility to re-use the RAM&#160;data even if a&#160;<br/>
reset&#160;(short power-loss, watchdog-reset)&#160;occurred.&#160;<br/>
Since CRC is quite time&#160;consuming,&#160;especially if performed frequently and/or over&#160;<br/>large data blocks, it might be more applicable to&#160;disable it&#160;using the option mentioned&#160;<br/>above.&#160;Then the data can only be re-used after a reset, if it did not change since last&#160;<br/>CRC recalculation, caused by a write request or after the last read request (if it was&#160;<br/>successful).&#160;<br/>
<b>&#160;</b><br/>
The CRC calculation is done in the cyclically called service&#160;NvM_MainFunction(). To&#160;be&#160;<br/>able to split a CRC calculation job, the number&#160;of CRC bytes to be calculated during one&#160;<br/>cycle can be configured via&#160;the Configuration tool.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
24&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=25></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-25_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-25_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info&#160;<br/></b>If an&#160;AUTOSAR compliant CRC library implementation is used, the NvM ensures for&#160;all&#160;<br/>
&#160;&#160;supported CRC types that calculated values do not depend&#160;on the number of cycles&#160;<br/>
needed for calculation, i.e. for any number&#160;of calculation steps any CRC&#160;value is&#160;<br/>guaranteed to be equal to the CRC value calculated over same data with one single&#160;<br/>call to the appropriate library function.&#160;<br/>
For CRC32&#160;this is a&#160;feature in NvM,&#160;beyond the requirements of&#160;AUTOSAR. For&#160;<br/>compatibility with older releases, this feature can&#160;be disabled&#160;for CRC32,&#160;which is not&#160;<br/>recommended, however.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>4.4.11&#160;&#160;Write Protection&#160;</b><br/>
The NVM&#160;supports write protection of&#160;any NV Block.&#160;The&#160;API services&#160;<br/>NvM_SetBlockProtection()&#160;is used for locking and unlocking a NV block.&#160;The initial&#160;<br/>write protection (after reset) can&#160;be configured. It will be&#160;set during&#160;NvM_ReadAll().&#160;<br/>
A&#160;block can also be configured to be written once.&#160;The write protection of such a block&#160;can&#160;<br/>not be removed by an&#160;API call. Nevertheless,&#160;it&#160;is possible to rewrite such a block by using&#160;<br/>the extended runtime&#160;preparation during&#160;NvM_ReadAll().&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention, for a dataset block configured as&#160;write once only one dataset can be&#160;<br/>
&#160;&#160;written.&#160;The&#160;other datasets can’t be written any more.&#160;The whole block is&#160;protected&#160;<br/>
after first write.&#160;<br/>
<b>&#160;</b><br/>
<b>4.4.12&#160;&#160;Erase and Invalidate&#160;</b><br/>
There are two services specified&#160;for making a NV block unreadable:&#160;<br/>NvM_EraseNvBlock()&#160;and&#160;NvM_InvalidateNvBlock().&#160;<br/>
Invalidating a block is much faster than erasing the block because only the status&#160;<br/>information will be invalidated.&#160;<br/>
<b>4.4.13&#160;&#160;Init Callbacks&#160;</b><br/>
For any block ROM defaults or&#160;an initialization callback can be configured.&#160;The init&#160;<br/>callback is called every time the default values of the block are to&#160;be loaded, e.g. during a&#160;<br/>restore block defaults service.&#160;<br/>
The return value of the functions is specified&#160;but will not be used by the NVM.&#160;<br/>
<b>4.4.14&#160;&#160;Define Locking/ Unlocking Services&#160;</b><br/>
In preemptive systems, it is necessary to protect some actions of preemption.&#160;That means&#160;<br/>that a few NVM internal actions&#160;need to be&#160;atomic. So for protecting these sequences&#160;<br/>functions for entering and leaving such a critical&#160;section can be configured. By default the&#160;<br/>Operating System (OS) services are used.&#160;<br/>
The Configuration tool can be used to define&#160;or configure services such as the OSEK&#160;<br/>services&#160;GetResource(…)&#160;and&#160;ReleaseResource(…)&#160;to lock and unlock resources.&#160;To&#160;<br/>use these services of your Operating System,&#160;you must also publish the header file of the&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
25&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=26></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-26_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
Operating System via Configuration tool (in the 'MyECU'&#160;window and the included tab 'OS&#160;<br/>Services').&#160;<br/>
<b>4.4.15&#160;&#160;Interrupts&#160;</b><br/>
When interrupts occur during write accesses,&#160;they do not corrupt already saved data or&#160;<br/>data to be written.&#160;To&#160;ensure this, this critical sections have to&#160;be locked, which is&#160;<br/>configurable via Configuration tool.&#160;<br/>
<b>4.4.16&#160;&#160;Data Corruption&#160;</b><br/>
Write operations to non-volatile memories&#160;are non-atomic operations.&#160;A&#160;power supply&#160;<br/>failure during write accesses may lead to corrupted/invalid data.&#160;Assuring that corrupted&#160;<br/>data will not be signaled as valid is no more&#160;the task of the NVM but of the FEE or EA.&#160;<br/>
<b>4.4.17&#160;&#160;Concurrent&#160;access to NV data for DCM&#160;</b><br/>
NVM provides possibility to access NV data concurrently with NVM’s applications.&#160;<br/>Therefore each configured NVRAM block has an additional alias.&#160;Aliases are neither read&#160;<br/>at start-up (during NvM_ReadAll processing) nor written at&#160;shut-down (during&#160;<br/>NvM_WriteAll processing). &#160;<br/>
For accessing the alias of a NVRAM block, NVM provides the global macro&#160;<br/>NvM_GetDcmBlockId().&#160;&#160;The macro expects the BlockId of the original NVRAM block&#160;<br/>as parameter and returns the block’s alias of type&#160;NvM_BlockIdType. Only one&#160;<br/>asynchronous request of one alias can be queued&#160;at a time. Otherwise the asynchronous&#160;<br/>API returns with E_NOT_OK, which indicates that the request&#160;has not been accepted,&#160;<br/>because of the block pending state check.&#160;<br/>
All jobs of DCM are always put into “Standard Job Queue”, even if blocks with immediate&#160;<br/>priority are requested and job prioritization is&#160;enabled. So cancellation of pending jobs by&#160;<br/>an immediate DCM-Block is avoided.&#160;The original priority itself is kept.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>DCM should&#160;lock the block with&#160;API NvM_SetBlockLockStatus (see chapt<a href="TechnicalReference_Asr_NvMs.html#45">er&#160;6.4.8)&#160;</a><br/>
&#160;&#160;before requesting the alias. In case&#160;of an error during job processing,&#160;DCM should also&#160;<br/>
unlock the block again. In case of a&#160;successful job processing the block is&#160;<br/>automatically unlocked&#160;after next start-up (after NvM_ReadAll processing). &#160;<br/>
Gets&#160;a block locked with&#160;NvM_SetBlockLockStatus, the original NVRAM block and the&#160;<br/>alias gets locked independent if the&#160;alias or the&#160;original block is requested.&#160;<br/>
<b>&#160;</b><br/>
<b>4.4.18&#160;&#160;Removed Functionality&#160;</b><br/>
Unlike in former versions of the NVM some&#160;functionality is no more the task of the NVM&#160;<br/>but of the FEE or the EA.&#160;Among this are:&#160;<br/>
&#160;&#160;Walking block concepts&#160;<br/>
&#160;&#160;Block&#160;allocation in memory&#160;<br/>
&#160;&#160;Force&#160;erase boundaries (of NV devices)&#160;<br/>
&#160;&#160;Methods for ensuring that corrupted data will not be signaled as valid&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
26&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=27></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>4.4.19&#160;&#160;Changed Functionality&#160;</b><br/>
Unlike in former versions of the NVM some functionality&#160;is changed:&#160;<br/>
The checksum is stored directly&#160;after the block data only in&#160;the NV memory. In RAM, CRC&#160;<br/>is not stored after the block data; it&#160;is stored in&#160;an internal variable.&#160;<br/>
<b>4.5&#160;&#160;Error Handling&#160;</b><br/>
<b>4.5.1&#160;</b><br/>
<b>Development Error Reporting&#160;</b><br/>
By default, development errors are reported to the DET&#160;using the service&#160;<br/>Det_ReportError()as&#160;&#160;specif<a href="TechnicalReference_Asr_NvMs.html#4">ied in&#160;[2]</a>, if development error reporting is&#160;enabled (i.e.&#160;<br/>pre-compile parameter&#160;NVM_DEV_ERROR_DETECT == STD_ON).&#160;<br/>
If another module is used for development error reporting, the function prototype for&#160;<br/>reporting the error can be configured by the integrator, but must have the same signature&#160;<br/>as the service&#160;Det_ReportError().&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#12">The reported NVM ID can be seen here [chapter&#160;3</a>].&#160;<br/>
The reported service IDs identify the services which are described in&#160;<a href="TechnicalReference_Asr_NvMs.html#40">6.4</a>. The&#160;following&#160;<br/>table presents the service IDs and the related services:&#160;<br/>
<b>Service ID&#160;</b><br/>
<b>Service&#160;</b><br/>
0x00&#160;NvM_Init()&#160;<br/>
0x01&#160;NvM_SetDataIndex()&#160;<br/>
0x02&#160;NvM_GetDataIndex()&#160;<br/>
0x03&#160;NvM_SetBlockProtection()&#160;<br/>
0x04&#160;NvM_GetErrorStatus()&#160;<br/>
0x05&#160;NvM_SetRamBlockStatus()&#160;<br/>
0x06&#160;NvM_ReadBlock()&#160;<br/>
0x07&#160;NvM_WriteBlock()&#160;<br/>
0x08&#160;NvM_RestoreBlockDefaults()&#160;<br/>
0x09&#160;NvM_EraseNvBlock()&#160;<br/>
0x0A&#160;<br/>
NvM_CancelWriteAll() &#160; &#160;&#160; &#160;<br/>
0x0B&#160;NvM_InvalidateNvBlock()&#160;<br/>
0x0C&#160;NvM_ReadAll()&#160;<br/>
0x0D&#160;NvM_WriteAll()&#160;<br/>
0x0E&#160;NvM_MainFunction()&#160;<br/>
0x0F&#160;NvM_GetVersionInfo()&#160;<br/>
0x10&#160;NvM_SetBlockLockStatus()&#160;<br/>
Table 4-4&#160;&#160;&#160;Mapping of service IDs to services&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
27&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=28></a>Technical Reference MICROSAR NVM&#160;<br/>
The errors reported to DET&#160;are described in the following table:&#160;<br/>
<b>Error Code&#160;</b><br/>
<b>Description&#160;</b><br/>
0x14&#160;NVM_E_NOT_INITIALIZED&#160;<br/>
Every&#160;API service, except&#160;NvM_Init()&#160;and&#160;<br/>NvM_GetVersionInfo(),&#160;may check if NVM has&#160;<br/>already been initialized.&#160;<br/>
0x15&#160;<br/>
NVM_E_BLOCK_PENDING&#160;&#160;As long as an asynchronous operation on a certain&#160;<br/>
Block has not been completed, no further requests&#160;<br/>belonging to&#160;this Block are allowed.&#160;&#160;<br/>
0x16&#160;<br/>
NVM_E_LIST_ OVERFLOW&#160;&#160;All asynchronous requests&#160;can only be en-queued if the&#160;<br/>
list is not full. &#160;<br/>
0x17&#160;NVM_E_NV_WRITE_PROT<br/>
NvM_WriteBlock(), NvM_EraseNvBlock()&#160;and&#160;<br/>
ECTED&#160;<br/>
NvM_InvalidateNvBlock()&#160;check,&#160;if&#160;the block with&#160;<br/>specified&#160;BlockId&#160;is write-protected,&#160;before it is&#160;written&#160;<br/>(or erased or&#160;invalidated). &#160;<br/>
0x18&#160;<br/>
NVM_E_BLOCK_CONFIG&#160;<br/>
This service&#160;is&#160;not possible with this&#160;configuration.&#160;<br/>
0x0A&#160;<br/>
NVM_E_PARAM_BLOCK_ID&#160;NVM&#160;API services may check, whether the passed&#160;<br/>
BlockId&#160;is in the allowed range.&#160;<br/>
0x0B&#160;NVM_E_PARAM_BLOCK_&#160;NvM_SetDataIndex()&#160;and&#160;NvM_GetDataIndex()&#160;are&#160;<br/>
TYPE&#160;<br/>
restricted to&#160;Dataset bocks. If these functions are&#160;called&#160;<br/>with any other bock type, this error code is produced.&#160;<br/>NvM_RestoreBlockDefaults()&#160;is restricted to blocks&#160;<br/>configured&#160;with ROM defaults&#160;or an&#160;init callback.&#160;<br/>
0x0C&#160;NVM_E_PARAM_BLOCK_D<br/>
NvM_SetDataIndex()&#160;may check the range of the&#160;<br/>
ATA_IDX&#160;<br/>
passed&#160;DataIndex. &#160;<br/>
0x0D&#160;NVM_E_PARAM_ADDRESS&#160;A&#160;wrong pointer parameter was passed. (NULL_PTR&#160;<br/>
passed in an asynchronous call,&#160;e.g.&#160;<br/>NvM_WriteBlock()&#160;for a non-permanent block)&#160;<br/>
0x0E&#160;NVM_E_PARAM_DATA&#160;<br/>
A&#160;NULL_PTR&#160;was passed&#160;in one of the&#160;synchronous&#160;<br/>functions&#160;NvM_GetDataIndex(),&#160;<br/>NvM_GetErrorStatus()&#160;or&#160;NvM_GetVersionInfo().&#160;<br/>
0x20&#160;NVM_E_RAM_BLOCK_LEN<br/>
At least one&#160;RAM block’s size does not fit to the size&#160;<br/>
GTH&#160;<br/>
that has been configured.&#160;<br/>
May only be reported by&#160;NvM_Init.&#160;<br/>
0x21&#160;NVM_E_ROM_BLOCK_LEN&#160;At least one&#160;ROM block’s size does&#160;not fit to the&#160;size&#160;<br/>
GTH&#160;<br/>
that has been configured.&#160;<br/>
May only be reported by&#160;NvM_Init.&#160;<br/>
Table 4-5&#160;&#160;&#160;Errors reported to DET&#160;<br/>
<b>4.5.1.1&#160;&#160;Parameter Checking&#160;</b><br/>
AUTOSAR requires that&#160;API functions check&#160;the validity&#160;of their parameters.&#160;The checks in&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#29">Table 4-6</a>&#160;are internal parameter checks of the&#160;API functions.&#160;These checks are for&#160;<br/>development error reporting and&#160;can be en-/disabled separately.&#160;The configuration of en-<br/>/disabling the checks<a href="TechnicalReference_Asr_NvMs.html#63">&#160;is described in chapter&#160;7.2</a>. En-/disabling of single checks is an&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
28&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=29></a>Technical Reference MICROSAR NVM&#160;<br/>
addition to the&#160;AUTOSAR standard which requires to en-/disable the complete&#160;parameter&#160;<br/>checking via the parameter&#160;NVM_DEV_ERROR_DETECT.&#160;<br/>
&#160;<br/>
The following table shows which parameter checks are performed on which services:&#160;<br/>
<b>Check&#160;</b><br/>
ck&#160;<br/>
ck&#160;<br/>
&#160;<br/>
&#160;<br/>
e&#160;<br/>
ding&#160;<br/>
k&#160;<br/>
e check&#160;<br/>
rit<br/>
&#160;<br/>
s&#160;<br/>
chec<br/>
s Manage-<br/>
yp<br/>
s W<br/>
s Pen<br/>
&#160;<br/>
ization&#160;<br/>
aIndex check&#160;<br/>
<b>Service&#160;</b><br/>
tate check&#160;<br/>
Module’<br/>
initial<br/>
Block’<br/>
ment T<br/>
Block’<br/>
Protection check&#160;<br/>
Block’<br/>
S<br/>
Block Id che<br/>
Dat<br/>
Pointers che<br/>
Block length<br/>
check &#160;<br/>
NvM_Init()&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
NvM_SetDataIndex()&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_GetDataIndex()&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_SetBlockProtection()&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_GetErrorStatus()&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_GetVersionInfo()&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_SetRamBlockStatus()&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_SetBlockLockStatus()&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_ReadBlock()&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_WriteBlock()&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_RestoreBlockDefaults()&#160;<br/>
&#160;&#160; &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
NvM_EraseNvBlock()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_CancelWriteAll()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_InvalidateNvBlock()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_ReadAll()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_WriteAll()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NvM_MainFunction()&#160;<br/>
&#160;&#160; &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
Table 4-6&#160;&#160;&#160;Development Error&#160;Checking:&#160;Assignment of checks to services&#160;<br/>
<b>4.5.2&#160;</b><br/>
<b>Production Code Error Reporting&#160;</b><br/>
Production code related errors are reported by&#160;default to the DEM using the service&#160;<br/>Dem_ReportErrorStatus()<a href="TechnicalReference_Asr_NvMs.html#4">&#160;as specified in&#160;[3].&#160;</a><br/>
However,&#160;the service to be used (and the appropriate include file)&#160;for error reporting may&#160;<br/>be configur<a href="TechnicalReference_Asr_NvMs.html#76">ed. Please refer to chapter&#160;7.2.5</a>.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
29&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=30></a>Technical Reference MICROSAR NVM&#160;<br/>
If another module is used for production code error reporting, the function prototype for&#160;<br/>reporting the error can be configured by the integrator, but must have the same signature&#160;<br/>as the service&#160;Dem_ReportErrorStatus().&#160;<br/>
The errors reported to DEM are described in the following table:&#160;<br/>
<b>Error Code&#160;</b><br/>
<b>Description&#160;</b><br/>
NVM_E_INTEGRITY_FAILED&#160;<br/>
API request integrity failed&#160;<br/>
NVM_E_REQ_FAILED&#160;<br/>
API request failed&#160;<br/>
Table 4-7&#160;&#160;&#160;Errors reported to DEM&#160;<br/>
Both shall have a value of type&#160;Dem_EventIdType&#160;(an integer type). It must be assured,&#160;<br/>that these two error codes as well as&#160;the&#160;type are “published” to the NvM via the user-<br/>specified include file.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
30&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=31></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>5&#160;&#160;Integration&#160;</b><br/>
This chapter gives necessary information for&#160;the integration of the MICROSAR NVM into&#160;<br/>an application environment of an ECU.&#160;<br/>
<b>5.1&#160;&#160;Scope of Delivery&#160;</b><br/>
The delivery of the NVM contains the files which are descri<a href="TechnicalReference_Asr_NvMs.html#31">bed in the chapters&#160;5.1.1</a>&#160;and&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#32">5.1.2</a>:&#160;<br/>
<b>5.1.1&#160;</b><br/>
<b>Static Files&#160;</b><br/>
<b>File Name&#160;</b><br/>
<b>Description&#160;</b><br/>
NvM.h&#160;<br/>
This file must not be modified by user.&#160;<br/>
Defines the interface of&#160;NVM.&#160;Only this file&#160;shall&#160;be included&#160;by the&#160;<br/>application.&#160;<br/>
NvM_Cbk.h&#160;<br/>
This file must not be modified by user.&#160;<br/>
Contains the declarations of the callback functions being invoked by&#160;<br/>EEPROM driver&#160;<br/>
NvM_Types.h&#160;<br/>
This file must not be modified by user.&#160;<br/>
Defines general types used by NVM.&#160;<br/>
NvM.c /&#160;<br/>
This file must not be modified by user.&#160;<br/>
NvM.lib/NvM.a&#160;<br/>
Implementation of NVM,&#160;delivered as object library.&#160;<br/>
NvM_Act /&#160;<br/>
These are files for internal use of the&#160;NvM.&#160;<br/>
NvM_Crc /&#160;<br/>
If NVM is delivered as object then this parts are content of NvM.lib.&#160;<br/>
NvM_JobProc /&#160;<br/>NvM_Qry /&#160;<br/>NvM_Queue.c *.h&#160;<br/>
Table 5-1&#160;&#160;&#160;Static files&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
31&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=32></a><img class="yflip" src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-32_1.png"/><br/>
<img class="yflip" src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-32_2.png"/><br/>
<img class="yflip" src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-32_3.png"/><br/>
<img class="yflip" src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-32_4.png"/><br/>
<img class="yflip" src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-32_5.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>5.1.2&#160;</b><br/>
<b>Dynamic Files&#160;</b><br/>
The dynamic files are generated by&#160;the configuration tool DaVinci Configurator. Do&#160;not&#160;<br/>modify them manually.&#160;<br/>
<b>File Name&#160;</b><br/>
<b>Description&#160;</b><br/>
NvM_Cfg.c&#160;<br/>
It contains configuration&#160;parameters&#160;of NVM&#160;which can be modified after&#160;<br/>compilation of&#160;NvM.c.&#160;<br/>
NvM_Cfg.h&#160;<br/>
Contains “public” configuration parameters of NVM.&#160;They are (or might be)&#160;<br/>also important to NvM’s user(s), or they may affect NvM’s&#160;API&#160;<br/>
It contains also “public” types and symbol declarations to be&#160;used by NVM&#160;<br/>as well as its user(s).&#160;<br/>
NvM_PrivateCfg.h&#160;&#160;Contains parameters as&#160;well as type and symbol declarations, which are&#160;<br/>
private to the NvM, i.e. they only affect internal&#160;behavior.&#160;<br/>
This file&#160;is intended to be&#160;included only by NvM’s sources.&#160;<br/>
Table 5-2&#160;&#160;&#160;Generated files&#160;&#160;&#160;<br/>
&#160;<br/>
<b>5.2&#160;&#160;Include Structure&#160;</b><br/>
The following figure&#160;illustrates&#160;the hierarchy&#160;of included files. It also shows that&#160;<br/>Std_Types.h and Nvm.h must be included by the application.&#160;<br/>
&#160;<br/>
<b>deployment&#160;Analysis&#160;Model</b><br/>
Appl.c<br/>
«include»<br/>
«include»<br/>
Std_Types.h<br/>
NvM.h<br/>
«include»<br/>
NvM_Cfg.h<br/>
«include»<br/>
NvM_Types.h<br/>
&#160;<br/>
Figure 5-1&#160;&#160;The file structure&#160;of the NVM sections module&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
32&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=33></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-33_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>5.3&#160;&#160;Compiler Abstraction and Memory&#160;Mapping &#160;</b><br/>
The objects (e.g. variables, functions, constants) are declared by compiler&#160;independent&#160;<br/>definitions – the compiler abstraction definitions. Each compiler abstraction definition is&#160;<br/>assigned to a memory section.&#160;<br/>
The following table contains the memory section names and the compiler abstraction&#160;<br/>definitions defined for the NVM and illustrates their assignment among each other.&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Compiler Abstraction&#160;</b><br/>
A<br/>T<br/>
A&#160;<br/>T<br/>
<b>Definitions&#160;</b><br/>
A&#160;<br/>
A&#160;<br/>
A<br/>
T<br/>
T<br/>
<b>&#160;</b><br/>
E_CODE<br/>
E_CONS<br/>
E_DA<br/>
T<br/>
T<br/>
T<br/>
IG_CONS<br/>
IG_D<br/>
&#160;<br/>
A<br/>
A<br/>
A<br/>
_DA<br/>
IC_CODE&#160;<br/>
IC_CONST<br/>
_CODE&#160;<br/>
_CONST&#160;<br/>
_DA<br/>
F<br/>
F<br/>
V<br/>
V<br/>
V<br/>
ST<br/>
&#160;<br/>
A<br/>
PRI<br/>
PRI<br/>
PRI<br/>
PUBL<br/>
PUBL<br/>
APPL<br/>
APPL<br/>
APPL<br/>
CON<br/>
CON<br/>
<b>Memory&#160;Mapping&#160;</b><br/>
<b>Sections&#160;</b><br/>
NVM_<br/>
NVM_<br/>
T<br/>
NVM_<br/>
NVM_F<br/>
NVM_<br/>
NVM_<br/>
NVM_<br/>
NVM_<br/>
NVM_<br/>
NVM_<br/>
T<br/>
NVM_<br/>
NVM_START_SEC_CODE&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NVM_START_SEC_&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
VAR_NOINIT_UNSPECIFIED&#160;<br/>
NVM_START_SEC_VAR_NOINIT_8<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
BIT&#160;<br/>
NVM_START_SEC_VAR_UNSPECIF<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
IED&#160;<br/>
NVM_START_SEC_VAR_FAST_8BI<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
T&#160;<br/>
NVM_START_SEC_&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
CONST_UNSPECIFIED&#160;<br/>
NVM_START_SEC_CONST_8BIT&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
NVM_START_SEC_CONST_16BIT&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
NVM_START_SEC_&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
CONST_DESCRIPTOR_TABLE&#160;<br/>
NVM_START_SEC_VAR_POWER_<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
 &#160;<br/>
ON_INIT_UNSPECIFIED&#160;<br/>
Table 5-3&#160;&#160;&#160;Compiler abstraction and memory&#160;mapping&#160;<br/>
For each start keyword, there is&#160;a stop keyword.&#160;As these stop keywords&#160;are used to&#160;<br/>restore the default section,&#160;the stop keywords do not need to be configured.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>The size of the section NVM_START_SEC_CONST_DESCRIPTOR_TABLE depends&#160;<br/>
&#160;&#160;on the configuration settings. It makes sense to&#160;create an own section for this item if it&#160;<br/>
becomes too big to link it into the same page/section as the&#160;elements of the&#160;<br/>MICROSAR NVM&#160;module. In this case the according memory modifier has to be used&#160;<br/>in order to address the elements in this section.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
33&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=34></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-34_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-34_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>&#160;</b><br/>
Above listed section keywords are compiler dependent.&#160;They are set in the files&#160;<br/>MemMap.h and&#160;Compiler.h/Compiler_Cfg.h. Compiler pragmas may be used to&#160;open and&#160;<br/>close a special memory section.&#160;As these&#160;pragmas are already&#160;used when creating the&#160;<br/>NVM library (object code) these parameters are not link-time configurable. Libraries with&#160;<br/>different settings can be obtained at Vector Informatik GmbH. Please refer to the Software&#160;<br/>release notes (SRN) (or to the delivered MemMap.h, Compiler.h/Compiler_Cfg.h) for the&#160;<br/>settings made for your delivery.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>The sections&#160;configured&#160;above have&#160;to fit to the link file&#160;configuration as&#160;well as to&#160;<br/>
&#160;&#160;the memory&#160;modifier settings in the Compiler&#160;Abstraction!&#160;<br/>
<b>&#160;</b><br/>
<b>5.4&#160;&#160;Dependencies on SW Modules&#160;</b><br/>
<b>5.4.1&#160;</b><br/>
<b>OSEK / AUTOSAR OS&#160;</b><br/>
An OS environment is not necessary unless it&#160;is used for interrupt or resource locking&#160;<br/>issues.&#160;<br/>
<b>5.4.2&#160;</b><br/>
<b>DEM&#160;</b><br/>
NVM depends on an implementation&#160;of the DEM. It is used to report errors occurred during&#160;<br/>processing.&#160;The header file declaring the&#160;API must be configured via Configuration tool.&#160;<br/>
<b>5.4.3&#160;</b><br/>
<b>DET&#160;</b><br/>
Module DET:&#160;Can be used in development mode. It records all development errors for&#160;<br/>evaluation purposes. Its usage can be enabled/disabled via Configuration tool by the&#160;<br/>switch “Development Error Reporting”.&#160;<br/>
<b>5.4.4&#160;</b><br/>
<b>MEMIF&#160;</b><br/>
The NVM uses configuration parameters defined by the MemIf.&#160;<br/>
<b>5.4.5&#160;</b><br/>
<b>CRC Library&#160;</b><br/>
For CRC calculations&#160;the NVM uses the services provided by an&#160;AUTOSAR compliant&#160;<br/>CRC Library.&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>Since the “Configuration&#160;Id Block” (see also chapt<a href="TechnicalReference_Asr_NvMs.html#67">er &#160;7.2.3) must be config</a>ured with&#160;<br/>
&#160;&#160;either CRC16 or CRC32;&#160;you will always need the CRC library.&#160;<br/>
<b>&#160;</b><br/>
<b>5.4.6&#160;</b><br/>
<b>Callback Functions&#160;</b><br/>
MICROSAR NVM offers the usage of notifications&#160;that can be mapped to callback&#160;<br/>functions provided by&#160;other modules, in order&#160;to inform them about job completion. For&#160;<br/>each NVRAM block a separate callback function may be defined by&#160;application. These&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
34&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=35></a>Technical Reference MICROSAR NVM&#160;<br/>
callback function declarations must be made&#160;within the application and&#160;be included by the&#160;<br/>NVM.&#160;<br/>
<b>5.4.7&#160;</b><br/>
<b>RTE&#160;</b><br/>
When at least one Service Port is enabled (see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#69">7.2.4) and corresponding PIM (see</a>&#160;<br/>TechnicalReference of&#160;RTE) is&#160;available, all additional necessary header files are included&#160;<br/>automatically. SWC must not include&#160;NvM.h.&#160;<br/>
<b>5.5&#160;&#160;Integration Steps&#160;</b><br/>
To&#160;integrate MICROSAR NVM into your system,&#160;several steps&#160;beginning with configuration&#160;<br/>have to be done:&#160;<br/>
&#160;&#160;Configure MICROSAR NVM and MICROSAR MEMIF according to applications’&#160;<br/>
requirements using MICROSAR Configuration tool or a GCE editor.&#160;&#160;<br/>
&#160;&#160;Generate the configuration files&#160;of the modules NVM and MEMIF.&#160;<br/>
&#160;&#160;Configure and generate the lower modules FEE/EA&#160;and the driver modules for&#160;<br/>
FLS/EEP.&#160;<br/>
&#160;&#160;If&#160;a FEE or EA&#160;module is&#160;used that is not&#160;delivered by Vector, make sure that the&#160;<br/>
parameters that are exchanged between the two modules are consistent.&#160;<br/>
&#160;&#160;Each application is responsible to&#160;make&#160;their RAM and ROM blocks available (do not&#160;<br/>
use the static modifier!).&#160;The MICROSAR NVM includes the&#160;file that declares these&#160;<br/>blocks and defines memory modifier to address the blocks.&#160;This memory modifier can&#160;<br/>be changed in the&#160;Compiler.h.&#160;<br/>
&#160;&#160;Make sure all applications using MICROSAR NVM include&#160;Std_Types.h&#160;and&#160;NvM.h&#160;<br/>
(in that order).&#160;<br/>
&#160;&#160;Check the initialization of the drivers FLS/EEP, FEE/EA&#160;and the MICROSAR NVM&#160;<br/>
(MICROSAR NVM does not initialize any other module).&#160;<br/>
&#160;&#160;Make sure that the initialization sequence is correct. FEE/EA&#160;and FLS/EEP&#160;must be&#160;<br/>
initialized before any NVM request (usually&#160;NvM_ReadAll()) can be used.&#160;<br/>
&#160;&#160;Ensure that the main functions of the NVM, the FEE/EA&#160;and the FLS/EEP&#160;drivers are&#160;<br/>
called cyclically.&#160;This&#160;must be done within&#160;an application task&#160;running at sufficient&#160;<br/>priority (to avoid starving).&#160;<br/>
&#160;&#160;Ensure that&#160;a waiting task frees CPU to make&#160;it possible that the action for the task is&#160;<br/>
waiting for,&#160;can be done!&#160;<br/>
Finally: Compile and link your MICROSAR NVM together with your project.&#160;<br/>
<b>5.6&#160;&#160;Estimating Resource Consumption&#160;</b><br/>
Besides&#160;resources needed anyway when using NVM,&#160;there are some configuration options&#160;<br/>influencing resource consumption of your system. In general&#160;these options affect usage&#160;<br/>independently of the number of&#160;configured NVRAM&#160;blocks.&#160;Additionally each NVRAM&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
35&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=36></a>Technical Reference MICROSAR NVM&#160;<br/>
block itself requires resources in RAM, ROM&#160;and NV, respectively.&#160;The following sections&#160;<br/>will summarize the options and give you hints, how to estimate their effects.&#160;<br/>
<b>5.6.1&#160;</b><br/>
<b>RAM Usage&#160;</b><br/>
In general, each NVRAM block consumes RAM&#160;– for the application-defined RAM-block&#160;as&#160;<br/>well as for the internal block management structure, which holds&#160;information about request&#160;<br/>results, blocks’&#160;attributes&#160;and the data indexes.&#160;The amount&#160;of RAM occupied by the RAM&#160;<br/>block itself&#160;should equal the configured length. However,&#160;the actual size depends on the&#160;<br/>size of the object (variable)&#160;the application declares.&#160;The size of each management area is&#160;<br/>currently 3 bytes.&#160;<br/>
The configuration options affecting RAM consumption pertain&#160;to size of the queue(s) and&#160;<br/>the option job prioritization.&#160;The size&#160;of one queue entry depends&#160;on the target platform&#160;<br/>and the compiler options used. It&#160;ranges from 8 bytes (16 bit platform, 16bit pointers) to 12&#160;<br/>bytes (32bit architectures,&#160;aligned structure members).&#160;<br/>
Additionally&#160;the setting “Internal Buffer for&#160;Crc Handling” affects RAM usage: If enabled,&#160;<br/>the NVM internally allocates a RAM buffer.&#160;Its&#160;size equals the size of largest configured&#160;<br/>NVRAM block with CRC, having&#160;a permanent RAM block associated, including CRC size. &#160;<br/>
Additionally, each NVRAM block&#160;with CRC automatically gets a dedicated RAM area for&#160;<br/>CRC storage, exactly&#160;matching CRC’s size.&#160;As&#160;a result, applications’&#160;RAM blocks do not&#160;<br/>need to provide additional space for CRC.&#160;Therefore it does not affect RAM consumption.&#160;<br/>
<b>5.6.2&#160;</b><br/>
<b>ROM Usage&#160;</b><br/>
The largest&#160;amount of ROM resources being&#160;needed depends on the&#160;number (and sizes)&#160;<br/>of blocks&#160;configured with ROM defaults.&#160;The remarks about RAM blocks&#160;also apply to&#160;<br/>ROM blocks. Especially for block management&#160;type 'DATASET_ROM'.&#160;The size of the&#160;<br/>object (variable) declared by application must be considered, rather than the configured&#160;<br/>NVRAM block length. &#160;<br/>
Because each NVRAM block’s configuration is compiled into&#160;a constant block descriptor,&#160;<br/>the ROM needed is&#160;also affected by the whole number of configured NVRAM blocks.&#160;<br/>Again, the size of one descriptor varies with the target platform and the compiler options&#160;<br/>used. It can be from 18 bytes (16bit architecture, 16bit pointers) to 44 bytes (32bit&#160;<br/>architecture, 32bit pointers,&#160;structure members aligned).&#160;<br/>
There are some configuration options affecting NVM's code size.&#160;The options &#160;<br/>
&#160;&#160;Development mode&#160;<br/>
&#160;&#160;API configuration class&#160;<br/>
&#160;&#160;use Version Info&#160;API&#160;<br/>
&#160;&#160;use Set Ram Block Status&#160;API&#160;<br/>
result in switching on/off complete code sections.&#160;<br/>
<b>5.6.3&#160;</b><br/>
<b>NV Usage&#160;</b><br/>
The requirements on NV memory space per device are affected by the NVRAM blocks&#160;and&#160;<br/>their configuration. Basically,&#160;each NV block&#160;allocates as many bytes as specified for its&#160;<br/>length, plus CRC bytes (if configured). Underlying components (FEE or EA) would also&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
36&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=37></a>Technical Reference MICROSAR NVM&#160;<br/>
add internal management information, as well as padding bytes to meet NV memory&#160;<br/>device’s alignment requirements.&#160;<br/>
According to the management type of the NVRAM block, it consists of one ore more&#160;<br/>blocks consuming NV space:&#160;<br/>
&#160;&#160;NATIVE&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;NV&#160;Block&#160;<br/>
&#160;&#160;REDUNDANT&#160;&#160;2 NV Blocks&#160;<br/>
&#160;&#160;DATASET&#160;<br/>
&#160; &#160;“Count”&#160;<br/>
NV&#160;<br/>
Blocks&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
37&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=38></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6&#160;&#160;API&#160;Description&#160;</b><br/>
<b>6.1&#160;&#160;Interfaces Overview&#160;</b><br/>
<a href="TechnicalReference_Asr_NvMs.html#14">For an interfaces overview please see&#160;Figure 3-2</a>.&#160;<br/>
<b>6.2&#160;&#160;Type Definitions&#160;</b><br/>
<b>Type Name&#160;</b><br/>
<b>C-Type&#160;&#160;Description&#160;</b><br/>
<b>Value Range&#160;</b><br/>
NvM_RequestResult&#160;<br/>
uint8&#160;<br/>
An asynchronous&#160;API&#160;<br/>
NVM_REQ_OK (see chapter&#160;<br/>
Type&#160;<br/>
service can have following&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
results&#160;or status that can be&#160;&#160;The last asynchronous&#160;request has&#160;<br/>
polled by&#160;<br/>
been finished&#160;successfully.&#160;This is the&#160;<br/>
NvM_GetErrorStatus()<br/>
default value&#160;after reset.&#160;This status&#160;<br/>
.&#160;<br/>
has the value&#160;0.&#160;<br/>
NVM_REQ_NOT_OK (see chapter&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
The last asynchronous&#160;request has&#160;<br/>been finished&#160;unsuccessfully.&#160;<br/>
NVM_REQ_PENDING (see chapter&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
An asynchronous request is&#160;currently&#160;<br/>being processed by the task.&#160;<br/>
NVM_REQ_INTEGRITY_FAILED&#160;(see&#160;<br/>chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
A&#160;NV block was supposed&#160;to be valid&#160;<br/>but it turned out that the data are&#160;<br/>corrupted (either CRC mismatch or&#160;the&#160;<br/>FEE or the EA&#160;reported an&#160;<br/>inconsistency).&#160;<br/>
NVM_REQ_BLOCK_SKIPPED (see&#160;<br/>chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
The block&#160;was skipped during a multi&#160;<br/>block request.&#160;<br/>
NVM_REQ_NV_INVALIDATED (see&#160;<br/>chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
The NV block is marked as&#160;invalid.&#160;<br/>
NVM_REQ_CANCELLED (see&#160;<br/>chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1)&#160;</a><br/>
The last asynchronous&#160;<br/>NvM_WriteAll()&#160;has been&#160;<br/>cancelled by&#160;<br/>NvM_CancelWriteAll().&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
38&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=39></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Type Name&#160;</b><br/>
<b>C-Type&#160;&#160;Description&#160;</b><br/>
<b>Value Range&#160;</b><br/>
NvM_BlockIdType&#160;uint16&#160;<br/>
It is the type&#160;of a block&#160;<br/>
[0&#160;<br/>
handle that is used by the&#160;<br/>
2^(16-<br/>
application in&#160;order to&#160;<br/>
NVM_DATASET_SELECTION_BITS)-<br/>
access a&#160;NVM block.&#160;There&#160;&#160;1]&#160;<br/>
are two&#160;reserved IDs:&#160;<br/>
NVM_DATASET_SELECTION_BITS&#160;is&#160;<br/>
&#160;&#160;Block ID&#160;0 for multi&#160;<br/>
the maximum&#160;number of bits&#160;that are&#160;<br/>
block requests (Block ID&#160;&#160;needed in order to store the maximum&#160;<br/>
0 is only allowed for&#160;API&#160;&#160;dataset value.&#160;<br/>
NvM_GetErrorStatus())&#160;<br/>and&#160;<br/>
Example:&#160;<br/>
<br/>
The dataset block with the&#160;greatest&#160;<br/>
&#160;&#160;Block ID&#160;1 for the&#160;<br/>
configuration Id block&#160;<br/>
number of datasets&#160;has six&#160;of them. So&#160;<br/>it is necessary to store the data index&#160;<br/>
The block handles&#160;are&#160;<br/>
0…5 to select&#160;the appropriate dataset&#160;<br/>
created as&#160;defines in an&#160;<br/>
block.&#160;To&#160;store the value five, three bits&#160;<br/>
ascending define list.&#160;<br/>
are necessary.&#160;So&#160;<br/>
&#160;<br/>
NVM_DATASET_SELECTION_BITS&#160;has&#160;<br/>
&#160;<br/>
the value 3.&#160;<br/>
This means that only the block IDs&#160;<br/>0…2^(16-3)-1&#160;= 2…8191 are available&#160;<br/>as block handles.&#160;<br/>
NvM_ServiceIdType&#160;uint8&#160;<br/>
Service Ids of the different&#160;<br/>
NVM_INIT (0u)&#160;<br/>
service routines of the&#160;<br/>
NVM_SET_DATA_INDEX (1u)&#160;<br/>
NVM.&#160;<br/>
NVM_GET_DATA_INDEX (2u)&#160;<br/>
NVM_SET_BLOCK_PROTECTION (3u)<br/>
NVM_GET_ERROR_STATUS (4u)&#160;<br/>
NVM_SET_RAM_BLOCK_STATUS (5u)<br/>
NVM_READ_BLOCK (6u)&#160;<br/>
NVM_WRITE_BLOCK (7u)&#160;<br/>
NVM_RESTORE_BLOCK_DEFAULTS&#160;<br/>(8u)&#160;<br/>
NVM_ERASE_BLOCK (9u)&#160;<br/>
NVM_CANCEL_WRITE_ALL (10u)&#160;<br/>
NVM_INVALIDATE_NV_BLOCK (11u)<br/>
NVM_READ_ALL (12u)&#160;<br/>
NVM_WRITE_ALL (13u)&#160;<br/>
NVM_MAINFUNCTION (14u)&#160;<br/>
NVM_GET_VERSION_INFO (15u)&#160;<br/>
NVM_SET_BLOCK_LOCK_STATUS&#160;<br/>(16u)&#160;<br/>
The single values are applied as&#160;<br/>defines.&#160;<br/>
See also&#160;chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#27">4.5.1&#160;</a><br/>
Table 6-1&#160;&#160;&#160;Type definitions&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
39&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=40></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.3&#160;&#160;Global API Constants&#160;</b><br/>
These NVM specific constants are available through the inclusion of&#160;NvM.h. They&#160;are&#160;<br/>configurable within DaVinci Configurator Pro.&#160;<br/>
&#160;&#160;NVM_COMPILED_CONFIG_ID: configured identifier for the NV memory layout &#160;<br/>
&#160;&#160;NVM_NO_OF_BLOCK_IDS: number of all defined NVRAM Blocks (including reserved&#160;<br/>
blocks)&#160;<br/>
&#160;&#160;Name of the NVRAM blocks&#160;<br/>
&#160;<br/>
<b>6.4&#160;&#160;Services provided by&#160;NVM&#160;</b><br/>
The NVM&#160;API consists of services, which are realized by function calls.&#160;<br/>
<b>6.4.1&#160;</b><br/>
<b>NvM_Init&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_Init&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Service for basic NVM initialization. (Exclusively&#160;called by ECU State Manager).&#160;The time consuming&#160;<br/>NVRAM block initialization&#160;and setup according&#160;to the&#160;block descriptor is done by the&#160;NvM_ReadAll&#160;<br/>request.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-2&#160;&#160;&#160;NvM_Init&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
40&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=41></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.2&#160;</b><br/>
<b>NvM_SetDataIndex&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_SetDataIndex&#160;</b>( NvM_BlockIdType BlockId, &#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uint8 DataIndex )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
DataIndex&#160;<br/>
Index position of a Block in&#160;the NV Block of Dataset type.&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request sets&#160;the specified index to associate a&#160;dataset NV block (with/without ROM blocks) with its&#160;<br/>corresponding RAM block.&#160;The&#160;DataIndex&#160;needs to have a valid value before a read/write/erase or&#160;<br/>invalidate request is initiated.&#160;<br/>
If the dataset block has a set of ROM defaults, this function is&#160;used&#160;(prior&#160;to&#160;NvM_ReadBlock()) to&#160;select&#160;<br/>the appropriate ROM set.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 2 or&#160;3 is configured. &#160;<br/>
&#160;&#160;The NVRAM manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-3&#160;&#160;&#160;NvM_SetDataIndex&#160;<br/>
<b>6.4.3&#160;</b><br/>
<b>NvM_GetDataIndex&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_GetDataIndex&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uint8* DataIndexPtr )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
DataIndexPtr&#160;<br/>
Address where the current DataIndex shall be written&#160;to&#160;<br/>
<b>Return code&#160;</b><br/>
Void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request passes the&#160;current DataIndex (association) of the specified dataset block.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 2 or&#160;3 is configured. &#160;<br/>
&#160;&#160;The NVRAM manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
41&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=42></a>Technical Reference MICROSAR NVM&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-4&#160;&#160;&#160;NvM_GetDataIndex&#160;<br/>
<b>6.4.4&#160;</b><br/>
<b>NvM_SetBlockProtection&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_SetBlockProtection&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; boolean ProtectionEnabled )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
ProtectionEnabled&#160;<br/>
This&#160;parameter is responsible for setting&#160;the write protection of a selected&#160;<br/>NVRAM block:&#160;<br/>
TRUE: enable&#160;protection&#160;<br/>
FALSE: disable protection&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request sets&#160;the write&#160;protection for&#160;the NV block.&#160;Any further write/erase/invalidate requests to the&#160;<br/>NVRAM block are&#160;rejected&#160;synchronously if&#160;the NV block-write protection is&#160;set.&#160;The data area&#160;of the RAM&#160;<br/>block remains writable in any case.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 3 is&#160;configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before this request is called.&#160;The protection can not be&#160;<br/>
released for a&#160;write once block that has&#160;already been&#160;written.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-5&#160;&#160;&#160;NvM_SetBlockProtection&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
42&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=43></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.5&#160;</b><br/>
<b>NvM_GetErrorStatus&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_GetErrorStatus&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uint8* RequestResultPtr )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
RequestResultPtr&#160;<br/>
Pointer where the result shall be written to.&#160;<br/>
Result is&#160;of type&#160;NvM_RequestResultType.&#160;All possible results are&#160;<br/>described in&#160;cha<a href="TechnicalReference_Asr_NvMs.html#38">pter&#160;6.2.&#160;</a><br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request reads the block dependent error/status&#160;information and&#160;writes it to the given address.&#160;The&#160;<br/>status/error&#160;information&#160;was set by a former or&#160;current&#160;asynchronous request.&#160;<br/>
This&#160;API can&#160;also be&#160;requested with BlockId 0&#160;(multi&#160;block).&#160;Then the multi block error/status information&#160;<br/>will be read to the given address. Only&#160;NvM_ReadAll()&#160;and&#160;NvM_WriteAll()&#160;are multi block requests&#160;<br/>and change the status/error information of the multi block.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-6&#160;&#160;&#160;NvM_GetErrorStatus&#160;<br/>
<b>6.4.6&#160;</b><br/>
<b>NvM_GetVersionInfo&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_GetVersionInfo&#160;</b>( Std_VersionInfoType* versioninfo )&#160;<br/>
<b>Parameter&#160;</b><br/>
versioninfo&#160;<br/>
Pointer to the&#160;address where the version&#160;info shall be&#160;written to.&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request writes&#160;the version info (Vendor ID, module ID, Instance ID, SW&#160;major version, SW minor&#160;<br/>version, SW patch version)&#160;to the given pointer.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if the pre-compile switch “Use&#160;version info&#160;API” is enabled.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
43&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=44></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-44_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-7&#160;&#160;&#160;NvM_GetVersionInfo&#160;<br/>
<b>6.4.7&#160;</b><br/>
<b>NvM_SetRamBlockStatus&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_SetRamBlockStatus&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;boolean BlockChanged ) &#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The block identifier.&#160;<br/>
BlockChanged&#160;<br/>
Sets&#160;the new&#160;status&#160;of the RAM block:&#160;<br/>
TRUE: Validates the RAM&#160;block and marks it as changed. If the block has a&#160;<br/>CRC and the option NVM_CALC_RAM_BLOCK_CRC&#160;is&#160;TRUE the CRC&#160;<br/>calculation is&#160;initiated.&#160;<br/>
FALSE: Mark the block as&#160;unchanged&#160;<br/>
<b>Return code&#160;</b><br/>
Void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
The request sets&#160;a block’s&#160;status&#160;to valid/changed respectively to unchanged. Setting a block to changed&#160;<br/>marks it for writing it during&#160;NvM_WriteAll().&#160;<br/>
If the block shall be set to “changed”, it&#160;has a&#160;CRC and the option&#160;NVM_CALC_RAM_BLOCK_CRC&#160;is&#160;TRUE&#160;<br/>the CRC calculation of the&#160;RAM block is&#160;initiated.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info&#160;<br/></b>Though this service is&#160;defined to operate&#160;synchronously,&#160;the CRC&#160;re-calculation&#160;will be&#160;<br/>
&#160;&#160;performed asynchronously.&#160;However,&#160;there is no&#160;restriction on accessing RAM block data, or&#160;on&#160;<br/>
calling other&#160;services. Consistency of data&#160;and CRC&#160;is ensured by WriteBlock/WriteAll, which&#160;<br/>will unconditionally recalculate the CRC&#160;before&#160;writing.&#160;Requesting&#160;CRC re-calculation, using&#160;<br/>NvM_SetRamBlockStatus&#160;again, will be&#160;recognized in a save way,&#160;the calculation will be re-<br/>queued, if necessary.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-8&#160;&#160;&#160;NvM_SetRamBlockStatus&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
44&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=45></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-45_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.8&#160;</b><br/>
<b>NvM_SetBlockLockStatus&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_SetBlockLockStatus&#160;</b>( NvM_BlockIdType BlockId, &#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; boolean Locked )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
Locked&#160;<br/>
This&#160;parameter is responsible for setting&#160;the lock protection&#160;status&#160;of a&#160;<br/>selected NVRAM&#160;block:&#160;<br/>
TRUE: Lock&#160;shall be enabled &#160;<br/>
FALSE: Lock&#160;shall be disabled&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Service for&#160;setting/resetting&#160;the lock of a&#160;NV block. &#160;<br/>
The NV contents&#160;associated&#160;to the NVRAM block identified by BlockId, will not be modified by&#160;any request.&#160;<br/>
The Block is&#160;skipped during&#160;NvM_WriteAll. Other requests, that are&#160;NvM_WriteBlock,&#160;<br/>NvM_InvalidateNvBlock,&#160;NvM_EraseNvBlock, return without error notification to Det or&#160;Dem. &#160;<br/>
During processing of&#160;NvM_ReadAll, this NVRAM block&#160;shall be&#160;loaded from&#160;NV memory.&#160;After loading&#160;the&#160;<br/>block from&#160;NV memory the lock is disabled again.&#160;<br/>
If a block gets locked with&#160;NvM_SetBlockLockStatus, the original NVRAM block and the alias is locked.&#160;<br/>The lock is independent on&#160;the requested&#160;BlockId,&#160;original one or&#160;DCM BlockId. (see&#160;chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#26">4.4.17</a>)&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>This function&#160;is an addition&#160;to the standard&#160;AUTOSAR specification.&#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available independent on&#160;API configuration class.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before this request is called.&#160;The protection can not be&#160;<br/>
released for a&#160;write once block that has&#160;already been&#160;written.&#160;<br/>
&#160;&#160;The service is only usable&#160;by BSW components, it is not accessible via RTE.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called by DCM.&#160;<br/>
Table 6-9&#160;&#160;&#160;NvM_SetBlockLockStatus&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
45&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=46></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.9&#160;</b><br/>
<b>NvM_MainFunction&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_MainFunction&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
This function&#160;has to be&#160;called cyclically. It is the entry&#160;point of the NVRAM Manager. In here the processing&#160;<br/>of the asynchronous jobs&#160;(read/write/erase/invalidate/CRC calculation…) is&#160;handled.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-10&#160;NvM_MainFunction&#160;<br/>
&#160;<br/>
<b>6.4.10&#160;&#160;NvM_ReadBlock&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_ReadBlock&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;uint8* NvM_DstPtr )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
NvM_DstPtr&#160;<br/>
Pointer where the data of a non-permanent&#160;RAM block&#160;shall be&#160;written to. If&#160;<br/>the block is permanent&#160;NULL_PTR&#160;shall&#160;be passed.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted, e.g. because of a list&#160;overflow.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to copy the data&#160;of the NV block to its&#160;corresponding RAM block.&#160;This function queues the&#160;read&#160;<br/>request and returns the acceptance result synchronously.&#160;&#160;<br/>
The NVM&#160;can&#160;notify the application by callback when the&#160;service&#160;is finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 2 or&#160;3 is configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before&#160;this request is called. In development mode the&#160;<br/>
service will not accept the call if the block is already queued (either for this or for a different service).&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
46&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=47></a>Technical Reference MICROSAR NVM&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-11&#160;&#160;NvM_ReadBlock&#160;<br/>
<b>6.4.11&#160;&#160;NvM_WriteBlock&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_WriteBlock&#160;</b>( NvM_BlockIdType BlockId,&#160;<br/>
&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; const uint8* NvM_SrcPtr )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
NvM_SrcPtr&#160;<br/>
Pointer where the data of a non-permanent RAM block&#160;shall be&#160;read from. If&#160;<br/>the block is permanent,&#160;NULL_PTR&#160;shall&#160;be passed.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted, e.g. list overflow.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request for copying data from the RAM&#160;block to its corresponding&#160;NV block.&#160;This&#160;function queues the write&#160;<br/>request and returns the acceptance result synchronously.&#160;&#160;<br/>
If the block has a CRC, the RAM block&#160;CRC will be recalculated before the data&#160;and the CRC are&#160;written&#160;to&#160;<br/>the NV memory, even if the service&#160;NvM_SetRamBlockStatus&#160;was called before and the configuration&#160;<br/>was&#160;set that within this&#160;service,&#160;the CRC calculation&#160;should be done.&#160;<br/>
If writing the data to NV memory fails, the NVM will&#160;retry writing.&#160;The number of&#160;write retries is&#160;a&#160;<br/>configuration option.&#160;<br/>
The NVM&#160;can&#160;notify the application by callback when the&#160;service&#160;is finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 2 or&#160;3 is configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before&#160;this request is called. In development mode the&#160;<br/>
service will not accept the call if the block is already queued (either for this or for a different service). If&#160;<br/>the block’s write protection is&#160;activated it can’t be&#160;written.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-12&#160;NvM_WriteBlock&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
47&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=48></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.12&#160;&#160;NvM_RestoreBlockDefaults&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_RestoreBlockDefaults&#160;</b>( NvM_BlockIdType BlockId,&#160;&#160;&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; uint8* NvM_DstPtr )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
NvM_DstPtr&#160;<br/>
Pointer where the data of a non-permanent&#160;RAM block&#160;shall be&#160;written to. If&#160;<br/>the block is permanent,&#160;NULL_PTR&#160;shall&#160;be passed.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted, e.g. list overflow.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to copy the ROM&#160;block default&#160;data to its&#160;corresponding&#160;RAM block.&#160;The selected block needs&#160;<br/>either ROM defaults&#160;or&#160;an initialization&#160;callback. &#160;<br/>
This function&#160;queues the restore&#160;request and returns the acceptance result synchronously.&#160;&#160;<br/>
The NVM&#160;can&#160;notify the application by callback when the&#160;service&#160;is finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 2 or&#160;3 is configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before&#160;this request is called. In development mode the&#160;<br/>
service will not accept the call if the block is already queued (either for this or for a different service).&#160;<br/>This function&#160;is not intended&#160;for reading&#160;ROM&#160;sets&#160;of a dataset ROM block. Use&#160;NvM_ReadBlock()&#160;<br/>instead for these blocks.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-13&#160;NvM_RestoreBlockDefaults&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
48&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=49></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-49_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.13&#160;&#160;NvM_EraseNvBlock&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_EraseNvBlock&#160;</b>( NvM_BlockIdType BlockId )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted, e.g. list overflow.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to erase a&#160;specified NV block.&#160;This function queues the erase request and returns the&#160;acceptance&#160;<br/>result synchronously.&#160;<br/>
The NVM&#160;can&#160;notify the application by&#160;callback when the&#160;service&#160;is finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 3 is&#160;configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before&#160;this request is called. In development mode the&#160;<br/>
service will not accept the call if the block is already queued (either for this or for a different service). If&#160;<br/>the block’s write protection is activated it also&#160;can’t be&#160;erased.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention that only high&#160;priority jobs&#160;(priority 0) can&#160;be erased!&#160;<br/>
&#160;<br/>
<b>&#160;&#160;</b>&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-14&#160;NvM_EraseNvBlock&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
49&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=50></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.14&#160;&#160;NvM_InvalidateNvBlock&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType&#160;<b>NvM_InvalidateNvBlock&#160;</b>( NvM_BlockIdType BlockId )&#160;<br/>
<b>Parameter&#160;</b><br/>
BlockId&#160;<br/>
The Block identifier.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Request has&#160;been accepted.&#160;<br/>
E_NOT_OK&#160;<br/>
Request has&#160;not been accepted, e.g. list overflow.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to invalidate a specified&#160;NV block.&#160;This&#160;function queues&#160;the invalidate&#160;request and&#160;returns the&#160;<br/>acceptance result synchronously.&#160;&#160;<br/>
The NVM&#160;can&#160;notify the application by callback when the&#160;service&#160;is finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if&#160;API configuration class 3 is&#160;configured. &#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized before&#160;this request is called. In development mode the&#160;<br/>
service will not accept the call if the block is already queued (either for this or for a different service). If&#160;<br/>the block’s write protection is activated it also&#160;can’t be invalidated.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-15&#160;NvM_InvalidateNvBlock&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
50&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=51></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-51_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.15&#160;&#160;NvM_ReadAll&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Void&#160;<b>NvM_ReadAll&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to (re)load&#160;all RAM blocks that&#160;have the option&#160;NVM_SELECT_BLOCK_FOR_READALL&#160;selected.&#160;<br/>The function queues the request that will be processed asynchronously in&#160;NvM_MainFunction().&#160;<br/>
Before reloading a block’s&#160;NV data,&#160;it first checks if the RAM block&#160;data is&#160;still valid.&#160;This can&#160;only be&#160;<br/>assured if the block&#160;has a checksum. In case of valid RAM&#160;data, the NV data&#160;will not be reloaded. &#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Non-permanent blocks and&#160;dataset blocks are also skipped during a ReadAll job.&#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
The first block that is read&#160;from NV memory is the configuration ID (block 1).&#160;The value is&#160;compared to the&#160;<br/>compiled configuration ID.&#160;The result of this check&#160;affects the further processing&#160;of&#160;the ReadAll job,&#160;<br/>depending on&#160;the setting of “Dynamic&#160;Configuration Handling” (see&#160;chap<a href="TechnicalReference_Asr_NvMs.html#65">ter&#160;7.2.2): If disabled,&#160;</a>all NVRAM&#160;<br/>blocks will be&#160;processed as&#160;described above, regardless of the result of reading/checking the&#160;configuration&#160;<br/>ID (match/mismatch/block&#160;invalid/integrity&#160;error/read failure).&#160;<br/>
If “Dynamic&#160;Configuration&#160;Handling”&#160;is enabled, the&#160;NVM loads all&#160;NVRAM blocks as&#160;described above, only&#160;<br/>if it detected a configuration ID match.&#160;Otherwise (including failures) those blocks having option “Resistant&#160;<br/>to Changed Software”&#160;(see&#160;chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#69">7.2.4) set will be lo</a>aded as&#160;if the configuration&#160;ID matched.&#160;The&#160;<br/>NVRAM blocks having this option cleared will be restored&#160;with&#160;ROM&#160;defaults, if available, and if&#160;“Select for&#160;<br/>ReadAll” was configured.&#160;<br/>
When&#160;the last&#160;block is reloaded the NVM&#160;can notify&#160;the application by&#160;callback (configurable multi block&#160;<br/>callback).&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;a multi block request.&#160;<br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This function&#160;is intended only to be called&#160;by the ECU State Manager during&#160;startup.&#160;<br/>
Table 6-16&#160;NvM_ReadAll&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
51&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=52></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-52_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>6.4.16&#160;&#160;NvM_WriteAll&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_WriteAll&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to write all blocks with changed&#160;RAM data to the NV memory.&#160;The function will queue&#160;the WriteAll&#160;<br/>job that will be processed asynchronously.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Non permanent and dataset&#160;blocks will not be written&#160;during&#160;NvM_WriteAll().&#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
When&#160;the last&#160;block is written the NVM can notify&#160;the application by&#160;callback (configurable multiblock&#160;<br/>callback).&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;a multi block request.&#160;<br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This function&#160;is intended only to be called&#160;by the ECU State Manager during&#160;shutdown.&#160;<br/>
Table 6-17&#160;NvM_WriteAll&#160;<br/>
<b>6.4.17&#160;&#160;NvM_CancelWriteAll&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_CancelWriteAll&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to cancel a running&#160;NvM_WriteAll()&#160;request.&#160;This&#160;call&#160;en-queues the request that&#160;will be&#160;<br/>processed asynchronously.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service is&#160;asynchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;always available.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
52&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=53></a>Technical Reference MICROSAR NVM&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called in application&#160;context.&#160;<br/>
Table 6-18&#160;NvM_CancelWriteAll&#160;<br/>
<b>6.4.18&#160;&#160;NvM_KillWriteAll&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_KillWriteAll&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Request to cancel a running&#160;NvM_WriteAll()&#160;request destructively.&#160;To keep required wake-up&#160;response&#160;<br/>times in an ECU the ECUM has the possibility to time-out a non-destructive&#160;NvM_CancelWriteAll()&#160;<br/>request.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
&#160;&#160;This&#160;service is&#160;available if the pre-compile switch&#160;“NvmKillWriteAllApi” (only in&#160;Generic Editor in&#160;<br/>
container “Nvm_30_CommonVendorParams”) is&#160;enabled independent on&#160;API configuration class.&#160;<br/>
&#160;&#160;The NVRAM Manager&#160;shall have been initialized&#160;before this request is called.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;This&#160;service is&#160;expected to&#160;be called by ECUM&#160;<br/>
Table 6-19&#160;NvM_KilllWriteAll&#160;<br/>
<b>6.5&#160;&#160;Services used by&#160;NVM&#160;</b><br/>
In the following table services provided by&#160;other components, which are used by the NVM&#160;<br/>are listed. For details&#160;about prototype and functionality refer&#160;to the documentation of the&#160;<br/>providing component.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
53&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=54></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Component&#160;</b><br/>
<b>API&#160;</b><br/>
DET&#160;Det_ReportError&#160;<br/>
DEM&#160;Dem_SetEventStatus&#160;<br/>
MEMIF&#160;MemIf_Read&#160;<br/>
MEMIF&#160;MemIf_InvalidateBlock&#160;<br/>
MEMIF&#160;MemIf_GetJobResult&#160;<br/>
MEMIF&#160;MemIf_Write&#160;<br/>
MEMIF&#160;MemIf_EraseImmediateBlock&#160;<br/>
MEMIF&#160;MemIf_GetStatus&#160;<br/>
MEMIF&#160;MemIf_Cancel&#160;<br/>
MEMIF&#160;MemIf_SetMode&#160;<br/>
CRC&#160;Crc_CalculateCRC16&#160;<br/>
CRC&#160;Crc_CalculateCRC32&#160;<br/>
EA&#160;<br/>
Used by MEMIF&#160;<br/>
FEE&#160;<br/>
Used by MEMIF&#160;<br/>
Table 6-20&#160;Services used by the NVM&#160;<br/>
<b>6.6&#160;&#160;Callback Functions&#160;</b><br/>
This chapter describes the callback functions that are implemented by the NVM and can&#160;<br/>be invoked by other modules.&#160;The prototypes of&#160;the callback functions&#160;are provided in the&#160;<br/>header file&#160;NvM_Cbk.h&#160;by the NVM.&#160;<br/>
<b>6.6.1&#160;</b><br/>
<b>NvM_JobEndNotification&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_JobEndNotification&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
Function&#160;to be used&#160;by the underlying memory abstraction to signal&#160;end of job without error.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;The callback&#160;function&#160;NvM_JobEndNotification&#160;is intended to be used by the underlying&#160;memory&#160;<br/>
abstraction&#160;(Fee/Ea) to signal end of job&#160;without error.&#160;<br/>
Table 6-21&#160;NvM_JobEndNotification&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
54&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=55></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>6.6.2&#160;</b><br/>
<b>NvM_JobErrorNotification&#160;</b><br/>
<b>Prototype&#160;</b><br/>
void&#160;<b>NvM_JobErrorNotification&#160;</b>( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
Function&#160;to be used&#160;by the underlying memory abstraction to signal&#160;end of job with error.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
Expected Caller Context&#160;<br/>
&#160;&#160;The callback&#160;function&#160;NvM_JobErrorNotification&#160;is intended to be used&#160;by the underlying memory&#160;<br/>
abstraction&#160;(Fee/Ea) to signal end of job&#160;with error.&#160;<br/>
Table 6-22&#160;NvM_JobErrorNotification&#160;<br/>
<b>6.7&#160;&#160;Configurable Interfaces&#160;</b><br/>
At its configurable interfaces the NVM defines&#160;notifications that&#160;can be mapped to callback&#160;<br/>functions provided by&#160;other modules.&#160;The mapping is&#160;not statically&#160;defined by the BSW&#160;<br/>module but can be performed at&#160;configuration time.&#160;The function prototypes that can be&#160;<br/>used for the configuration have to match&#160;the appropriate function&#160;prototype signatures,&#160;<br/>which are described in the&#160;following sub-chapters.&#160;<br/>
<b>6.7.1&#160;</b><br/>
<b>&#160;SingleBlockCallbackFunction&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType &lt;<b>SingleBlockCallbackFunction&gt;</b>&#160;( NvM_ServiceIdType ServiceId, &#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;NvM_RequestResultType JobResult )&#160;<br/>
<b>Parameter&#160;</b><br/>
ServiceId&#160;<br/>
The service identifier (see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#38">6.2) of the comple</a>ted request.&#160;<br/>
NvM_ServiceIdType&#160;is&#160;of type&#160;uint8.&#160;<br/>
JobResult&#160;<br/>
Result of the single block job.&#160;<br/>
<b>Return code&#160;</b><br/>
E_OK&#160;<br/>
Callback function has been&#160;processed successfully&#160;<br/>
E_NOT_OK&#160;<br/>
Callback function has not been&#160;processed successfully.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Callback routine to notify the upper layer&#160;that an asynchronous&#160;single block request has been finished.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
55&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=56></a>Technical Reference MICROSAR NVM&#160;<br/>
Call Context&#160;<br/>
&#160;&#160;Called from&#160;NvM_MainFunction&#160;<br/>
&#160;&#160;Asynchronous block processing completed (except&#160;NvM_WriteAll, for&#160;NvM_ReadAll&#160;it is&#160;<br/>
configurable)&#160;<br/>
Table 6-23&#160;SingleBlockCallbackFunction&#160;<br/>
<b>6.7.2&#160;</b><br/>
<b>MultiBlockCallbackFunction &#160;</b><br/>
<b>Prototype&#160;</b><br/>
void &lt;<b>MultiBlockCallbackFunction&gt;</b>&#160;( NvM_ServiceIdType ServiceId, &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; NvM_RequestResultType JobResult )&#160;<br/>
<b>Parameter&#160;</b><br/>
ServiceId&#160;<br/>
The service identifier (see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#38">6.2) of the comple</a>ted request.&#160;<br/>
NvM_ServiceIdType&#160;is&#160;of type&#160;uint8.&#160;<br/>
JobResult&#160;<br/>
Result of the multi block job.&#160;<br/>
<b>Return code&#160;</b><br/>
void&#160;<br/>
--&#160;<br/>
<b>Functional Description&#160;</b><br/>
Common callback routine to notify the upper layer that&#160;an asynchronous multi block request has been&#160;<br/>finished. &#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant.&#160;<br/>
Call Context&#160;<br/>
&#160;&#160;Called from&#160;NvM_MainFunction.&#160;<br/>
&#160;&#160;Called upon&#160;completion of&#160;NvM_ReadAll&#160;and&#160;NvM_WriteAll, respectively&#160;<br/>
Table 6-24&#160;MultiBlockCallbackFunction&#160;<br/>
<b>6.7.3&#160;</b><br/>
<b>InitBlockCallbackFunction&#160;</b><br/>
<b>Prototype&#160;</b><br/>
Std_ReturnType &lt;<b>InitBlockCallbackFunction&gt;</b>&#160;( void )&#160;<br/>
<b>Parameter&#160;</b><br/>
--&#160;<br/>
--&#160;<br/>
<b>Return code&#160;</b><br/>
Std_ReturnType&#160;<br/>
NvM always&#160;returns&#160;E_OK.&#160;<br/>
<b>Functional Description&#160;</b><br/>
Callback routine which&#160;shall be called by the NvM module to copy default data to a RAM block&#160;if a ROM&#160;<br/>block is&#160;configured.&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service&#160;is&#160;synchronous.&#160;<br/>
&#160;&#160;This&#160;service is&#160;non re-entrant&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
56&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=57></a>Technical Reference MICROSAR NVM&#160;<br/>
Call Context&#160;<br/>
&#160;&#160;Called from&#160;NvM_MainFunction&#160;<br/>
&#160;&#160;Called during&#160;processing of&#160;NvM_ReadAll, if application shall copy default values&#160;into the&#160;<br/>
corresponding RAM block.&#160;<br/>
Table 6-25&#160;InitBlockCallbackFunction&#160;<br/>
<b>6.8&#160;&#160;Service Ports&#160;</b><br/>
Via Service Ports the software components (SWC) have the possibility to execute services&#160;<br/>of the NVM with an abstract RTE interface.&#160;Hence, the software components&#160;are&#160;<br/>independent from the underlying basic software stack.&#160;<br/>
<b>6.8.1&#160;</b><br/>
<b>Client Server Interface&#160;</b><br/>
A&#160;client server interface is related to a Provide Port&#160;(PPort) at the server side and a&#160;<br/>Require Port (RPort) at client side.&#160;<br/>
Configuration dependent naming details<a href="TechnicalReference_Asr_NvMs.html#62">&#160;are described in the chapters&#160;7.1.3&#160;and&#160;7.1.4</a>.&#160;<br/>
<b>6.8.1.1&#160;&#160;Provide Ports on NVM side&#160;</b><br/>
At the PPorts of the NVM the&#160;API functions described in&#160;<a href="TechnicalReference_Asr_NvMs.html#40">6.4</a>&#160;are available as Runnable&#160;<br/>Entities.&#160;The Runnable Entities are invoked via Operations.&#160;The mapping from a SWC&#160;<br/>client call to&#160;an Operation is performed by&#160;the RTE. In this mapping the RTE adds Port&#160;<br/>Defined&#160;Argument Values to the client&#160;call of the SWC, if configured.&#160;<br/>
The following subchapters present the PPorts defined for the&#160;NVM and their Operations,&#160;<br/>the&#160;API functions related to those Operations&#160;and the Port Defined&#160;Argument Values to be&#160;<br/>added by the RTE:&#160;<br/>
<b>6.8.1.1.1&#160;&#160;PAdmin_&lt;BlockName&gt;&#160;</b><br/>
A&#160;port of type ’PAdmin’&#160;is a PPort&#160;of one NVRAM block,&#160;which is configured to use Service&#160;<br/>Ports.&#160;<br/>
If the SWC setting “Long Service Port Names” is&#160;enabled, the name of the service ports&#160;is&#160;<br/>PAdmin_&lt;BlockName&gt;; if “Long Service Port&#160;Names” is disabled, the name is&#160;<br/>PAdmin_&lt;BlockId&gt;.&#160;<br/>
Available if&#160;API Config Class = 3&#160;<br/>
<b>Operation&#160;</b><br/>
<b>API Function&#160;</b><br/>
<b>Port Defined&#160;Argument Values&#160;</b><br/>
SetBlockProtection&#160;NvM_SetBlockProtection()&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
Table 6-26&#160;Operations of Port Prototype PAdmin_&lt;BlockName&gt;&#160;<br/>
<b>6.8.1.1.2&#160;&#160;PS_&lt;BlockName&gt;&#160;</b><br/>
A&#160;port of type ’PS’&#160;is&#160;a PPort of one NVRAM&#160;block, which is configured to use Service&#160;<br/>Ports.&#160;<br/>
If the SWC setting “Long Service Port Names” is&#160;enabled, the name of the service ports&#160;is&#160;<br/>PS_&lt;BlockName&gt;; if “Long Service Port Names”&#160;is disabled, the name is PS_&lt;BlockId&gt;.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
57&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=58></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Operation&#160;</b><br/>
<b>API Function&#160;</b><br/>
<b>Port Defined&#160;Argument Values&#160;</b><br/>
GetErrorStatus&#160;1&#160;NvM_GetErrorStatus()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
SetRamBlockStatus1&#160;NvM_SetRamBlockStatus()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
SetDataIndex2,5&#160;NvM_SetDataIndex()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
GetDataIndex2,5&#160;NvM_GetDataIndex()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
ReadBlock2&#160;NvM_ReadBlock()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
WriteBlock2&#160;NvM_WriteBlock()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
RestoreBlockDefaults2, 6&#160;NvM_RestoreBlockDefaults()&#160;<br/>
NvM_BlockIdType4&#160;1..n&#160;<br/>
EraseBlock3&#160;NvM_EraseNvBlock()&#160;<br/>
NvM_BlockIdType4&#160;1..n&#160;<br/>
InvalidateNvBlock3&#160;NvM_InvalidateNvBlock()&#160;&#160;NvM_BlockIdType4&#160;1..n&#160;<br/>
Table 6-27&#160;Operations of Port Prototype PS_&lt;BlockName&gt;&#160;<br/>
1)&#160;Always&#160;<br/>
available&#160;<br/>
2)&#160;&#160;Available if&#160;API Config Class &gt;= 2&#160;<br/>3)&#160;&#160;Available if&#160;API Config Class = 3&#160;<br/>4)&#160;&#160;Is derived from the block’s&#160;position in the configuration&#160;<br/>5)&#160;&#160;Only available for blocks of Management&#160;Type Dataset&#160;<br/>6)&#160;&#160;Only available for blocks&#160;with Rom defaults&#160;configured&#160;<br/>
<b>6.8.1.2&#160;&#160;Require Ports&#160;</b><br/>
NvM invokes callbacks using RPorts.&#160;These Operations have to be provided by the SWCs&#160;<br/>by means of Runnable Entities&#160;using PPorts.&#160;These Runnable Entities implement the&#160;<br/>callback functions expected by the NVM.&#160;<br/>
The following subchapters present the Require&#160;Ports defined for the NVM, the Operations&#160;<br/>that are called from the NVM and&#160;the related Notifications, which are described in chapter&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#55">6.7</a>.&#160;<br/>
<b>6.8.1.2.1&#160;&#160;NvM_RpNotifyFinished_Id&lt;BlockName&gt;&#160;</b><br/>
A&#160;port of type ‘NvM_RpNotifyFinished_Id’&#160;is&#160;a RPort of one NVRAM block, which is&#160;<br/>configured to use Service Ports.&#160;<br/>
If the SWC setting “Long Service Port Names” is&#160;enabled, the name of the service ports&#160;is&#160;<br/>NvM_RpNotifyFinished_Id&lt;BlockName&gt;; if “Long Service Port Names” is disabled, the&#160;<br/>name is NvM_RpNotifyFinished_Id&lt;BlockId&gt;.&#160;<br/>
Available in all&#160;API Config Classes&#160;but “Use Callbacks” must be enabled.&#160;<br/>
<b>Operation&#160;</b><br/>
<b>Notification&#160;</b><br/>
JobFinished&#160;SingleBlockCallbackFunction&#160;<br/>
Table 6-28&#160;Operation of Port&#160;prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt;&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
58&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=59></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-59_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>7&#160;&#160;Configuration&#160;</b><br/>
<b>7.1&#160;</b><br/>
<b>Software Component Template&#160;</b><br/>
<b>7.1.1&#160;</b><br/>
<b>Generation&#160;</b><br/>
The definition of the Provide Ports is described in an XML&#160;file.&#160;This file describes the NVM&#160;<br/>as a software component with ports to which other applications can connect.&#160;This XML&#160;file&#160;<br/>can be generated on demand&#160;by DaVinci Configurator via the menu&#160;<br/>“ToolsÆAUTOSARÆSW-CÆNvM”.&#160;Additionally, DaVinci Configurator Pro&#160;also generates&#160;<br/>this file at the end of each generation process&#160;automatically.&#160;The target directory for SW-C&#160;<br/>files can be set via the menu “ToolsÆPreferencesÆNvMÆSW-C Files”.&#160;<br/>
&#160;<br/>
Figure 7-1&#160;&#160;Generate an&#160;NVM software component template&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
59&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=60></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-60_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
&#160;<br/>
Figure 7-2&#160;&#160;Change target directory for all generated SW-C files of NvM.&#160;<br/>
&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
60&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=61></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-61_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>7.1.2&#160;</b><br/>
<b>Import into DaVinci Developer&#160;</b><br/>
For further processing the generated software component template file has&#160;to be imported&#160;<br/>into DaVinci Developer.&#160;This can be done&#160;while a DaVinci-project is open by clicking&#160;<br/>“FileÆImport XML&#160;File...”. Choose the&#160;correct file for the import.&#160;<br/>
&#160;<br/>
Figure 7-3&#160;&#160;Import a new software component&#160;into DaVinci Developer&#160;<br/>
After importing the NVM as software component there is a new&#160;component type in the&#160;<br/>library view available.&#160;After double clicking&#160;the component NVM, all configured ports&#160;are&#160;<br/>presented.&#160;<br/>
The DaVinci tool suite lets you design the complete architecture of a car,&#160;consisting of&#160;<br/>several ECUs, each with its own NVM.&#160;Therefore it is desirable to import several NVM SW-<br/>C descriptions, each containing the description of an NVM to be&#160;mapped to a particular&#160;<br/>ECU. Using the 'Service Component Name Parameter' you can give your configurations&#160;<br/>meaningful unique names.&#160;All&#160;elements of the SW-C description are unique in this&#160;<br/>particular configuration and are prefixed with this&#160;parameter’s value. However,&#160;most&#160;<br/>elements are common to all SW-C descriptions, or are at&#160;least unique to the used&#160;<br/>configuration (which is also expressed by the elements’&#160;names) so that some elements&#160;are&#160;<br/>contained in each different SW-C description.&#160;During import, DaVinci will warn you about&#160;<br/>these doubled elements.&#160;You can ignore them (overwrite the existing elements); they are&#160;<br/>identical.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
61&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=62></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>7.1.3&#160;</b><br/>
<b>Dependencies on Configuration of NVM Attributes&#160;</b><br/>
The configuration of the NVM attributes (described in chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#63">7.2) highly influences the</a>&#160;<br/>resulting SW-C Description. So, the value&#160;of the parameter 'Service Component Name'&#160;<br/>influences the names of several elements in&#160;the description, especially the name of the&#160;<br/>'Service Component'. It is also the prefix&#160;for several other names that belong to this&#160;<br/>particular NVM configuration (and&#160;the resulting service component).&#160;<br/>
There is a&#160;couple of&#160;different port interfaces that will be generated, depending on&#160;the&#160;<br/>particular configuration. Each&#160;generated interface that results&#160;from a specific configuration&#160;<br/>has a unique name, i.e. in different SW-C descriptions port interfaces&#160;with the same name&#160;<br/>are compatible; they provide the same operations, each with the same arguments of same&#160;<br/>type.&#160;<br/>
<b>7.1.3.1&#160;&#160;Naming of Service Port Interfaces&#160;</b><br/>
The Service Port Interface provides the prototypes of the elementary block related&#160;<br/>services of&#160;the NVM, such as&#160;read data from NV memory, write data to NV memory. It&#160;<br/>generally contains the string 'Srv'.&#160;<br/>
As described above, port interfaces resulting from different&#160;configurations, have different&#160;<br/>names.&#160;These names are given according to this scheme:&#160;<br/>
&#160;&#160;Each&#160;Interface is prefixed by 'NvM_'&#160;<br/>
&#160;&#160;'Set&#160;Ram Block Status&#160;Api'&#160;Æ&#160;if enabled, the interface name contains the string 'SRBS',&#160;<br/>
and it contains the operation SetRamBlockStatus.&#160;<br/>
&#160;&#160;'API&#160;Configuration Class'&#160;Æ&#160;the interface name contains a&#160;short string that denotes the&#160;<br/>
API configuration class&#160;it belongs to: 'AC1', 'AC2' or 'AC3'.&#160;The operations the interface&#160;<br/>describes in that configuration&#160;<a href="TechnicalReference_Asr_NvMs.html#57">class are described in Chapter &#160;6.8.1.1.&#160;</a><br/>
&#160;&#160;Availability of ROM default data&#160;Æ&#160;the interface contains the operation&#160;<br/>
RestoreBlockDefaults; it contains&#160;the string 'Defs'.&#160;This&#160;interface will be used by all P-<br/>Port-Prototypes belonging to a NVRAM block that was configured with ROM default&#160;<br/>data.&#160;<br/>
&#160;&#160;Block Management&#160;Type 'DATASET'&#160;Æ&#160;the interface provides the operations&#160;<br/>
GetDataIndex and SetDataIndex. Its name contains 'DS'.&#160;This interface will be used by&#160;<br/>all NVRAM&#160;blocks of Management&#160;Type 'DATASET'&#160;<br/>
The first two possibilities are common within&#160;one SW-C Description. Only one combination&#160;<br/>of them will occur.&#160;Unless 'API Configuration Class 1' was&#160;chosen, Port Interfaces&#160;<br/>describing any combination of the latter two possibilities&#160;may be generated.&#160;<br/>
<b>7.1.4&#160;</b><br/>
<b>Service Port Prototypes&#160;</b><br/>
For each active NVRAM block (including the configuration ID block)&#160;that was configured&#160;<br/>with 'Use Service Ports' port, prototypes will&#160;be&#160;generated.&#160;The port interfaces they are&#160;<br/>based on can differ.&#160;The interfaces depend on the&#160;block’s configuration, and hence on the&#160;<br/>operations that are necessary for current block.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
62&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=63></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>7.1.4.1&#160;&#160;Port Prototype Naming&#160;</b><br/>
The short name uniquely identifying the prototype is based on the numeric block ID (which,&#160;<br/>in turn, is derived from the block’s position in the configuration) and the port interface&#160;<br/>&#34;class” it corresponds to.&#160;<br/>
Each prototype is prefixed by&#160;the String&#160;'NvM_'; the next substring describes&#160;the&#160;<br/>corresponding port interface, and whether it is&#160;a Provide Port ('Pp') or a Require Port&#160;<br/>('Rp'):&#160;<br/>
&#160;&#160;'PAdmin'&#160;&#160;Æ&#160;Linked with port interface 'NvM_Administration' (only in 'API Configuration&#160;<br/>
Class 3')&#160;<br/>
&#160;&#160;'PS'&#160;Æ&#160;Linked with Port Interface&#160;'NvM_AC{1|2|3}[_SRBS][_Defs][_DS]_Srv'. The&#160;actual&#160;<br/>
interface depends on the possibilities described above.&#160;<br/>
&#160;&#160;'NvM_RpNotifyFinished'&#160;&#160;Æ&#160;Linked with Port Interface NvM_NotifyJobFinished that&#160;<br/>
describes the interface used by the NVM&#160;for 'single block job end notification'&#160;<br/>
If SWC setting “Long Service Port&#160;Names” is disabled,&#160;each port prototype’s&#160;name is post&#160;<br/>fixed by '_Id{BlockId}'. If SWC setting “Long Service Port Names” is enabled, each port&#160;<br/>prototype’s&#160;name is post fixed by&#160;'_{BlockName}'. &#160;<br/>
Additionally&#160;each port prototype contains&#160;a long name as well&#160;as a description, which&#160;<br/>describe it in a better,&#160;human&#160;readable form.&#160;They contain the logical block name, as&#160;<br/>configured,&#160;instead of the block ID, and&#160;the used port interface’s short name.&#160;<br/>
<b>7.2&#160;&#160;Configuration of NVM Attributes&#160;</b><br/>
In the NVM the attributes can be&#160;configured with the following methods:&#160;<br/>
&#160;&#160;Configuration in DaVinci Configurator&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
63&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=64></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-64_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Because&#160;AUTOSAR forbids the use&#160;of the&#160;sizeof-operator in production&#160;code, the&#160;<br/>
&#160;&#160;exact sizes&#160;of your NVRAM blocks,&#160;and hence your data structures must be known at&#160;<br/>
configuration time.&#160;Therefore you are required to determine these values by yourself.&#160;<br/>This leads to some significant pitfalls:&#160;<br/>
&#160;&#160;The sizes of basic&#160;data types are platform dependent.&#160;To&#160;handle this problem, you should&#160;<br/>
use only&#160;AUTOSAR data types as&#160;defined&#160;in&#160;Std_Types.h&#160;(respectively&#160;<br/>Platform_Types.h).&#160;They are defined&#160;to have the same&#160;size on&#160;all platforms.&#160;The&#160;<br/>enumeration type’s size also depends on&#160;your platform, the compiler and its options. Be&#160;<br/>aware of the size the compiler actually chooses. Usually an&#160;enum&#160;equals to an&#160;int&#160;by&#160;<br/>default, but you can force it to be the smallest possible&#160;type (e.g.&#160;char).&#160;<br/>
&#160;&#160;Be aware of the composition of bit fields. It can be affected by compiler&#160;switches.&#160;<br/>
&#160;&#160;The compiler may rearrange members of&#160;structures&#160;to save memory.&#160;The best solution&#160;<br/>
would be to arrange members according&#160;to their type manually.&#160;The compiler may add&#160;<br/>unused&#160;padding bytes to increase&#160;accessibility to the members of&#160;a structure.&#160;According to&#160;<br/>the previous&#160;fact, you should order your&#160;structure’s members. Doing so, you should be&#160;<br/>aware of aligned start addresses&#160;for larger integral data&#160;types (e.g.&#160;uint16&#160;or&#160;uint32)&#160;<br/>according to the CPU’s requirements for&#160;accessing them.&#160;<br/>
&#160;&#160;As stated&#160;above, some compiler&#160;switches influence the sizes of data types. Keep in mind&#160;<br/>
that changing&#160;these ones&#160;may result in changed sizes of your data&#160;blocks, leading to a&#160;<br/>reconfiguration of NVM.&#160;<br/>
A&#160;good way&#160;to determine the blocks’&#160;sizes&#160;is to extract the required information from&#160;<br/>the linker file or from the generated object.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
<b>7.2.1&#160;</b><br/>
<b>Start configuration of the NVM&#160;</b><br/>
The component name of the NVRAM Manager in DaVinci Configurator is&#160;“NvM”. In the&#160;<br/>“Architecture view” (initial page) of DaVinci Configurator the NvM can be opened by&#160;its&#160;<br/>context menu to start its configuration.&#160;The NvM can also be opened for configuration&#160;<br/>using the Project Explorer, selecting Memory&#160;Æ&#160;Services&#160;Æ&#160;NvM.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
64&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=65></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>7.2.2&#160;</b><br/>
<b>General Settings&#160;</b><br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
SWC Settings&#160;<br/>
Service&#160;<br/>
link-time&#160;string&#160;<br/>
Valid&#160;<br/>
C-<br/>
Create a unique name space for&#160;<br/>
Component&#160;<br/>
name,&#160;<br/>
the NVM.&#160;This name is&#160;used for&#160;<br/>
Name&#160;<br/>
maximum&#160;<br/>
SWC Description generation.&#160;The&#160;<br/>
length: 20&#160;<br/>
generated component will get this&#160;<br/>
characters,&#160;&#160;name. Several names will be&#160;<br/>default:&#160;<br/>
prefixed with this name.&#160;<br/>
<b>NvM&#160;</b><br/>
Long Service Port&#160;&#160;link-time&#160;bool&#160;<br/>
<b>ON&#160;</b><br/>
Enables long service port names;&#160;<br/>
Names&#160;<br/>
OFF&#160;<br/>
Each port prototype’s name is post&#160;<br/>fixed by '{BlockName}' instead of&#160;<br/>‘{BlockId}’&#160;<br/>
Queues and&#160;API configuration&#160;<br/>
API Configuration&#160;<br/>
pre-compile&#160;--&#160;<br/>
Class&#160;<br/>
1&#160;Different classes with&#160;API function&#160;<br/>
Class&#160;<br/>
Class 2&#160;<br/>
sets&#160;can be&#160;selected.&#160;<br/>
<b>Class 3&#160;</b><br/>
By setting this preprocessor&#160;<br/>switch to 'Class 1' the following&#160;<br/>options are&#160;disabled:&#160;<br/>
NVM_JOB_PRIORISATION&#160;<br/>
NVM_SIZE_STANDARD_JOB_QUEUE&#160;<br/>
NVM_SIZE_IMMEDIATE_JOB_QUEUE<br/>
Use Version&#160;Info&#160;<br/>
pre-compile&#160;--&#160;<br/>
ON&#160;<br/>
Use&#160;NvM_GetVersionInfo().&#160;<br/>
API&#160;<br/>
<b>OFF&#160;</b><br/>
Use Set Ram&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
Use&#160;NvM_SetRamBlockStatus().<br/>
Block Status&#160;API&#160;<br/>
OFF&#160;<br/>
Job Prioritization&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
Enable the prioritized queuing of&#160;<br/>
<b>OFF&#160;</b><br/>
jobs.&#160;<br/>
Size of Standard&#160;<br/>
link-time&#160;integer&#160;<br/>
1..&#160;&#160;Size of the standard job queue.&#160;<br/>
Job Queue&#160;<br/>
<b>8&#160;</b><br/>
..254&#160;<br/>
Size of Immediate&#160;<br/>
link-time&#160;integer&#160;<br/>
<b>1&#160;</b><br/>
Size of the immediate job queue.&#160;<br/>
Job Queue&#160;<br/>
..254&#160;<br/>
Configuration option&#160;<br/>
ID of this&#160;<br/>
link-time&#160;integer&#160;<br/>
0..&#160;&#160;Compiled configuration set&#160;<br/>
Configuration Set&#160;<br/>
<b>1&#160;</b><br/>
identifier.&#160;<br/>
..65535&#160;<br/>
Dynamic&#160;<br/>
pre-compile&#160;--&#160;<br/>
ON&#160;<br/>
Enable/disable dynamic&#160;<br/>
Configuration&#160;<br/>
<b>OFF&#160;</b><br/>
configuration handling.&#160;<br/>
Handling&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
65&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=66></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Further settings&#160;<br/>
Drive Mode&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
If this option&#160;is selected,&#160;the drive&#160;<br/>
<b>OFF&#160;</b><br/>
mode of the underlying memory&#160;<br/>devices will&#160;be set to fast during&#160;<br/>multi block services.&#160;<br/>
Polling Mode&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
If this option&#160;is selected,&#160;NVM&#160;<br/>
OFF&#160;<br/>
polls the underlying layer till job&#160;<br/>completion.&#160;The callback functions&#160;<br/>are not used&#160;by the lower layer&#160;<br/>and must be disabled in&#160;this layer.&#160;<br/>
Internal Buffer for&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
Enable and disable internal Crc&#160;<br/>
Crc Handling&#160;<br/>
OFF&#160;<br/>
Buffer. If Internal Crc Buffer is&#160;<br/>enabled, NvM handles Crc in an&#160;<br/>internal buffer. Memory for Crc&#160;<br/>must not be allocated at&#160;the end of&#160;<br/>Ram Block. If internal Crc Buffer is&#160;<br/>disabled, Memory for&#160;Crc at the&#160;<br/>end of Ram&#160;Block is necessary!&#160;<br/>
CRC Bytes&#160;per&#160;<br/>
link-time&#160;integer&#160;<br/>
1..&#160;&#160;Maximum number of bytes of a&#160;<br/>
Cycle&#160;<br/>
<b>64&#160;</b><br/>
CRC checksum that are&#160;<br/>calculated&#160;during one cycle of&#160;<br/>
.. 65535&#160;<br/>
NvM_MainFunction.&#160;<br/>
Max. Number&#160;of&#160;<br/>
link-time&#160;integer&#160;<br/>
0..&#160;&#160;Number of retries until a&#160;write job&#160;<br/>
Write Retries&#160;<br/>
<b>1&#160;</b><br/>
fails.&#160;<br/>
..7&#160;<br/>
Dataset Selection&#160;<br/>
link-time&#160;integer&#160;<br/>
1..&#160;&#160;Defines the&#160;number of least&#160;<br/>
Bits&#160;<br/>
<b>4&#160;</b><br/>
significant bits&#160;which are used to&#160;<br/>address a dataset of a block of&#160;<br/>
..8&#160;<br/>
type dataset (see chapter<a href="TechnicalReference_Asr_NvMs.html#21">&#160;4.4.5.2).</a><br/>
Critical Sections&#160;<br/>
Function Set&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
all named&#160;<br/>
The different services to&#160;protect&#160;<br/>
sets&#160;<br/>
critical sections can be&#160;defined in&#160;<br/>
defined in&#160;<br/>
'MyECU'.&#160;<br/>
'MyECU',&#160;<br/>default:&#160;<br/>
<b>UseSuspe<br/>ndFunctio<br/>ns&#160;</b><br/>
Table 7-1&#160;&#160;&#160;General Settings&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
66&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=67></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-67_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>7.2.3&#160;</b><br/>
<b>Special NVRAM Blocks&#160;</b><br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Config ID Block&#160;<br/>
Name&#160;link-time&#160;<br/>
C-<br/>
Valid C-<br/>
Logical name of the reserved&#160;<br/>
identifie&#160;identifier,&#160;<br/>
configuration block to be used&#160;<br/>
r&#160;<br/>
default:&#160;<br/>
within the application.&#160;<br/>
<b>ConfigBlo<br/>ck&#160;</b><br/>
Device&#160;link-time&#160;<br/>
FEE/EA&#160;<br/>
All&#160;<br/>
The device (Memory Hardware&#160;<br/>
or third&#160;<br/>
configured&#160;&#160;Abstraction)&#160;the configuration&#160;<br/>
party&#160;<br/>
NV&#160;<br/>
block is located in.&#160;<br/>
module&#160;&#160;abstraction&#160;<br/>
devices&#160;<br/>(FEE/EA&#160;<br/>…), no&#160;<br/>default.&#160;<br/>
CRC Type&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
<b>CRC16&#160;</b><br/>
CRC type for this block.&#160;<br/>
CRC32&#160;<br/>
Ram&#160;Block&#160;<br/>
link-time&#160;<br/>
C-<br/>
Valid C-<br/>
Symbolic name of the RAM block&#160;<br/>
identifie&#160;identifier,&#160;<br/>
(Variable name as defined by&#160;<br/>
r&#160;<br/>
default:&#160;<br/>
application)&#160;<br/>
<b>CfgId_Ra</b><br/>
If no name is defined, RAM Block&#160;<br/>
<b>mBlock&#160;</b><br/>
will be defined by NvM.&#160;<br/>
Single Block&#160;<br/>
link-time&#160;C-<br/>
<b>NULL_PT</b><br/>
Name of the&#160;callback function&#160;<br/>
Callback&#160;<br/>
identifie&#160;<b>R&#160;</b><br/>
supplied by&#160;application, if used.&#160;<br/>
r&#160;<br/>
or other&#160;<br/>
This field&#160;is&#160;disabled, if 'Use&#160;<br/>
valid C-<br/>
Service Ports' is checked,&#160;<br/>
identifier&#160;<br/>
because in this case, the callback&#160;<br/>will be invoked, depending on RTE&#160;<br/>configuration (Port Mapping).&#160;<br/>
It is also disabled, if 'Use Job End&#160;<br/>Callback' is&#160;unchecked.&#160;<br/>
Requirement Id&#160;<br/>
link-time&#160;<br/>
C-<br/>
valid C-<br/>
A&#160;requirement id may be&#160;entered&#160;<br/>
identifie&#160;identifier&#160;<br/>
here for traceability reason.&#160;<br/>
r&#160;<br/>
Priority&#160;link-time&#160;<br/>
integer&#160;<br/>
0..&#160;<br/>
Priority of the Config ID Block&#160;<br/>
<b>127&#160;</b><br/>
<b>&#160;</b><br/>
..255&#160;<br/>
<b>Info</b>&#160;<br/>Note that a priority&#160;<br/>
(0&#160;<br/>
&#160;&#160;of 0 (immediate) is&#160;<br/>
=immediat<br/>
possible,&#160;but not&#160;<br/>
e)&#160;<br/>
recommended.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
67&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=68></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-68_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
RAM CRC&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
Enable/disable the calculation of&#160;<br/>
OFF&#160;<br/>
CRC in RAM, upon&#160;<br/>NvM_SetRamBlockStatus(true)&#160;<br/>request.&#160;<br/>
Write Once&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
Configure block as write&#160;once.&#160;<br/>
<b>OFF&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>When using&#160;<br/>
&#160;&#160;'Dynamic&#160;<br/>
Configuration&#160;<br/>Handling', this&#160;<br/>option should be&#160;<br/>unchecked.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
Initially Write&#160;<br/>
link-time&#160;--&#160;ON&#160;&#160;Write protection enabled&#160;after&#160;<br/>
Protected&#160;<br/>
<b>OFF&#160;</b><br/>
reset.&#160;<br/>
Use Service Ports&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
Mark the configured block as&#160;<br/>
OFF&#160;<br/>
accessible via service ports.&#160;The&#160;<br/>block name&#160;will be derived from&#160;<br/>the symbolic name.&#160;<br/>
Use Job End&#160;<br/>
link-time&#160;--&#160;<b>ON&#160;</b><br/>
Enable/disable usage of&#160;the&#160;<br/>
Callback&#160;<br/>
OFF&#160;<br/>
'single block job end notification'&#160;<br/>callback&#160;<br/>
Use Job End&#160;<br/>
link-time&#160;--&#160;ON&#160;&#160;Enable/disable usage of&#160;the&#160;<br/>
Callback during&#160;<br/>
<b>OFF&#160;</b><br/>
'single block job end notification'&#160;<br/>
NvM_ReadAll&#160;<br/>
callback during NvM_ReadAll,&#160;<br/>when this block has been&#160;<br/>processed. It depends on the&#160;<br/>runtime-environment, whether this&#160;<br/>option may&#160;be enabled,&#160;or not.&#160;<br/>E.g., if the application&#160;is&#160;not yet&#160;<br/>initialized, when NvM_ReadAll is&#160;<br/>being processed, or (in&#160;case of&#160;<br/>Service Ports usage) if the RTE is&#160;<br/>not initialized yet, this option&#160;<br/>should be disabled.&#160;<br/>
Multiblock Request Status&#160;<br/>
Blockname&#160;link-time&#160;C-<br/>
Valid C-<br/>
Logical name of the reserved&#160;<br/>
identifie&#160;identifier,&#160;<br/>
'Multiblock request status&#160;block'&#160;<br/>
r&#160;<br/>
default:&#160;<br/>
(ID 0).&#160;<br/>
<b>MultiBlock<br/>Request&#160;</b><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
68&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=69></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Callback&#160;link-time&#160;<br/>
C-<br/>
<b>NULL_PT</b><br/>
Name of the&#160;callback function&#160;<br/>
identifie&#160;<b>R&#160;</b><br/>
supplied by&#160;application, if used.&#160;<br/>
r&#160;<br/>
or other&#160;<br/>valid C-<br/>identifier&#160;<br/>
Include Files&#160;<br/>
Include List&#160;<br/>
link-time&#160;<br/>
header&#160;<br/>
Valid&#160;<br/>
List of all includes, declaring the&#160;<br/>
file&#160;<br/>
header file,&#160;&#160;callback functions used&#160;(including&#160;<br/>default:&#160;<br/>
the callbacks for the configuration&#160;<br/>
<b>Applicatio</b><br/>
block as well as the Multiblock&#160;<br/>
<b>n.h&#160;</b><br/>
Request Result Block)&#160;and the&#160;<br/>extern declarations of RAM and&#160;<br/>ROM blocks. Only files appearing&#160;<br/>in the list will be recognized.&#160;A&#160;file&#160;<br/>name in the edit filed will be&#160;<br/>ignored, unless it’s&#160;added using&#160;<br/>the 'Add' button&#160;<br/>
If NVRAM&#160;Blocks are&#160;configured&#160;<br/>to 'Use Service Ports' and with&#160;<br/>callbacks, you need to configure&#160;<br/>an RTE include file. It needs to be&#160;<br/>named Rte_&lt;Service Component&#160;<br/>Name&gt;.h&#160;<br/>
Table 7-2&#160;&#160;&#160;Special NVRAM&#160;blocks&#160;<br/>
<b>7.2.4&#160;</b><br/>
<b>User Block Description&#160;</b><br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Block Description&#160;<br/>
Identifier&#160;link-time&#160;<br/>
integer&#160;<br/>
1..&#160;<br/>
Numeric handle of the&#160;NVRAM&#160;<br/>
<b>2</b>..&#160;<br/>
Block to be&#160;passed as BlockId&#160;<br/>parameter to&#160;the NvM.&#160;This value&#160;<br/>
.. 65535<b>&#160;</b><br/>
will be calculated automatically. In&#160;<br/>DaVinci Configurator Pro it is not&#160;<br/>writeable by the user.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
69&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=70></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Name&#160;link-time&#160;<br/>
C-<br/>
Valid C-<br/>
Logical name of the User Block, to&#160;<br/>
identifie&#160;identifier,&#160;<br/>
be used within your application&#160;<br/>
r&#160;<br/>
must be&#160;<br/>
(Don’t use the numeric Block IDs,&#160;<br/>
unique,&#160;<br/>
represented&#160;by the names,&#160;<br/>
default:&#160;<br/>
directly).&#160;A&#160;block handle&#160;with this&#160;<br/>
<b>Appl_Nvm&#160;</b>name will be generated.&#160;<br/><b>Block1&#160;</b><br/>
This name will also be&#160;used in&#160;<br/>Descriptions and long names of&#160;<br/>the NVM’s SWC Description.&#160;<br/>
Device&#160;link-time&#160;<br/>
FEE/EA&#160;<br/>
All&#160;<br/>
The device the User Block is&#160;<br/>
or&#160;<br/>
configured&#160;&#160;located in.&#160;<br/>
dummie&#160;NV&#160;<br/>s&#160;<br/>
abstraction&#160;<br/>devices&#160;<br/>(FEE/EA&#160;or&#160;<br/>dummies),&#160;<br/><b>no default</b>.<br/>
MngmtType&#160;link-time&#160;--&#160;<b>Native&#160;</b><br/>
Management&#160;Type of the User&#160;<br/>
Redundant&#160;&#160;Block.&#160;<br/>
Dataset&#160;<br/>
CRC Type&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
<b>OFF&#160;</b><br/>
CRC protection to be used for the&#160;<br/>
CRC16&#160;<br/>
User Block.&#160;<br/>
CRC32&#160;<br/>
RAM CRC&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
If checked, the CRC of the RAM&#160;<br/>
<b>OFF&#160;</b><br/>
block is recalculated when&#160;<br/>NvM_SetRamBlockStatus(TRUE)&#160;<br/>is called.&#160;<br/>
Prio&#160;link-time&#160;<br/>
integer&#160;<br/>
0..&#160;<br/>
Priority of the User Block.&#160;<br/>
<b>127&#160;</b><br/>
..255&#160;<br/>
(0&#160;<br/>=immediat<br/>e)&#160;<br/>
Length&#160;link-time&#160;<br/>
integer&#160;<br/>
<b>1&#160;</b><br/>
Length of the User Block in bytes.&#160;<br/>
.. 65535&#160;<br/>
Count&#160;link-time&#160;<br/>
integer&#160;<br/>
<b>Native: 1&#160;</b><br/>
Number of&#160;mapped blocks in&#160;the&#160;<br/>
Redundant&#160;NV area. Dependant on the&#160;<br/>: 2&#160;<br/>
management type.&#160;<br/>
Dataset:&#160;<br/>2...255&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
70&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=71></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-71_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Further Settings&#160;<br/>
Service Ports&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
Generate service port description&#160;<br/>
OFF&#160;<br/>
for the configured block.&#160;<br/>
If checked,&#160;the parameters 'Use&#160;<br/>Init Callback', 'Init Callback' and&#160;<br/>'Job End Callback' are&#160;disabled&#160;<br/>
WO&#160;link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
<b>W</b>rite&#160;<b>O</b>nce Flag.&#160;A&#160;write once&#160;<br/>
<b>OFF&#160;</b><br/>
block can only be written once.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention that a&#160;<br/>
&#160;&#160;dataset block set to&#160;<br/>
write once cannot be&#160;<br/>written once&#160;for all its&#160;<br/>datasets. Only one&#160;<br/>dataset could be&#160;<br/>written.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
IWP&#160;link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
<b>I</b>nitial&#160;<b>W</b>rite&#160;<b>P</b>rotection for this&#160;<br/>
<b>OFF&#160;</b><br/>
block. Defines the state&#160;of this&#160;<br/>block’s user-definable write&#160;<br/>protection after start-up.&#160;<br/>
Res&#160;link-time&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
<b>Res</b>istant to changed software&#160;<br/>
OFF&#160;<br/>
Option influences the block&#160;<br/>handling during&#160;NvM_ReadAll().&#160;<br/>
ReadAll&#160;link-time&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
If checked&#160;the block will be read&#160;<br/>
OFF&#160;<br/>
from NV during&#160;NvM_ReadAll().&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
71&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=72></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-72_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-72_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Cbk @ ReadAll&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
Enable/disable usage of&#160;the&#160;<br/>
<b>OFF&#160;</b><br/>
'single block job end notification'&#160;<br/>callback during NvM_ReadAll in&#160;<br/>contrast to the typical behaviour&#160;<br/>where only the ‘multiblock job end&#160;<br/>notification’&#160;would be called.&#160;<br/>Nevertheless the ‘multiblock job&#160;<br/>end notification’&#160;will be called after&#160;<br/>processing&#160;of all configured&#160;<br/>“ReadAll”-blocks.&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>It depends on&#160;the&#160;<br/>
&#160;&#160;runtime-environment,&#160;<br/>
whether this&#160;option&#160;<br/>may be enbled, or&#160;<br/>not. E.g., if&#160;the&#160;<br/>application is&#160;not yet&#160;<br/>initialized, when&#160;<br/>NvM_ReadAll&#160;is&#160;<br/>being processed, or&#160;<br/>(in case of Service&#160;<br/>Ports usage)&#160;if the&#160;<br/>RTE is not initialized&#160;<br/>yet, this&#160;option should&#160;<br/>be disabled.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
RAM&#160;Block&#160;<br/>
link-time&#160;<br/>
C-<br/>
NULL_PTR&#160;&#160;Symbolic name of the RAM block&#160;<br/>
identifie&#160;or other&#160;<br/>
(Variable name as defined by&#160;<br/>
r&#160;<br/>
valid C-<br/>
application).&#160;If the block&#160;is non-<br/>
identifier,&#160;<br/>
permanent the field can&#160;be left&#160;<br/>
default:&#160;<br/>
empty or a&#160;NULL_PTR&#160;can be&#160;<br/>
<b>RamBlock&#160;</b>entered.&#160;<br/><b>Data1&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>A&#160;RAM block&#160;must&#160;<br/>
&#160;&#160;not be allocated, if&#160;<br/>
the block is&#160;<br/>configured&#160;by RTE.&#160;<br/>The field can be left&#160;<br/>empty or a&#160;<br/>NULL_PTR&#160;can be&#160;<br/>entered.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
72&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=73></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-73_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-73_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Service Port Settings&#160;<br/>
ROM&#160;Block&#160;<br/>
link-time&#160;<br/>
C-<br/>
<b>NULL_PT</b><br/>
If the block&#160;shall have ROM&#160;<br/>
identifie&#160;<b>R&#160;</b><br/>
defaults&#160;the&#160;name of the constant&#160;<br/>
r&#160;<br/>
or other&#160;<br/>
must be entered in this field&#160;<br/>
valid C-<br/>
(constant name as defined by&#160;<br/>
identifier&#160;<br/>
application).&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention that a&#160;<br/>
&#160;&#160;block can only have&#160;<br/>
either ROM&#160;defaults&#160;<br/>or an init call-back. If&#160;<br/>the ROM block is&#160;<br/>configured which&#160;<br/>means that it is not&#160;<br/>empty and not&#160;<br/>NULL_PTR,&#160;the&#160;<br/>setting of the Init&#160;<br/>Callback will&#160;be&#160;<br/>ignored.&#160;<br/>
<b>&#160;<br/>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>Info&#160;<br/></b>A&#160;ROM&#160;block must&#160;<br/>
&#160;&#160;not be allocated, if&#160;<br/>
the block&#160;is&#160;<br/>configured by&#160;RTE.&#160;<br/>The field can be left&#160;<br/>empty or a&#160;<br/>NULL_PTR can&#160;be&#160;<br/>entered.&#160;<br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
73&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=74></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-74_1.png"/><br/>
<img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-74_2.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Use Init Callback&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
An alternative to ROM defaults&#160;is&#160;<br/>
<b>OFF&#160;</b><br/>
the use of an init callback. Checks&#160;<br/>this control to enable usage of the&#160;<br/>init callback.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention that a&#160;<br/>
&#160;&#160;block can only have&#160;<br/>
either ROM&#160;defaults&#160;<br/>or an init call-back. If&#160;<br/>a ROM&#160;Block was&#160;<br/>configured,&#160;or if the&#160;<br/>'Init Callback' was not&#160;<br/>set, this option does&#160;<br/>not have any effects.&#160;<br/>
If 'Use Service Ports'&#160;<br/>was enabled, this&#160;<br/>option is disabled,&#160;<br/>because it&#160;cannot be&#160;<br/>guaranteed that the&#160;<br/>init callback&#160;can be&#160;<br/>invoked during&#160;<br/>NvM_ReadAll&#160;<br/>processing,&#160;as it is&#160;<br/>unclear whether the&#160;<br/>RTE is running.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
Init Callback&#160;<br/>
link-time&#160;<br/>
C-<br/>
<b>NULL_PT</b><br/>
An alternative to ROM defaults&#160;is&#160;<br/>
identifie&#160;<b>R&#160;</b><br/>
the use of an init callback. Enter&#160;<br/>
r&#160;<br/>
or other&#160;<br/>
the name in this field&#160;as&#160;defined&#160;<br/>
valid C-<br/>
by the aplication.&#160;This control is&#160;<br/>
identifier&#160;<br/>
disabled, if 'Use Service Ports'&#160;<br/>was checked.&#160;<br/>
<b>&#160;</b><br/>
<b>Caution&#160;<br/></b>Pay attention that a&#160;<br/>
&#160;&#160;block can only have&#160;<br/>
either ROM&#160;defaults&#160;<br/>or an init call-back. If&#160;<br/>a ROM block was&#160;<br/>configured, the 'Init&#160;<br/>Callback' will be&#160;<br/>ignored.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
74&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=75></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-75_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Use Job End Cbk&#160;<br/>
link-time&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
Use the Job&#160;end callback. If&#160;<br/>
<b>OFF&#160;</b><br/>
checked, the control 'Job End&#160;<br/>Callback' is&#160;enabled, unless 'Use&#160;<br/>Service Ports' was also&#160;checked.&#160;<br/>
Job End Callback&#160;<br/>
link-time&#160;<br/>
C-<br/>
<b>NULL_PT</b><br/>
Name of the&#160;callback function&#160;<br/>
identifie&#160;<b>R&#160;</b><br/>
supplied by&#160;application, if used.&#160;<br/>
r&#160;<br/>
or other&#160;<br/>
<b>&#160;</b><br/>
valid C-<br/>
<b>Caution&#160;</b><br/>
identifier&#160;<br/>
If 'Use Service Ports'&#160;<br/>
&#160;&#160;was chosen,&#160;the&#160;<br/>
name of the callback&#160;<br/>is implicitly defined.&#160;<br/>Thus this&#160;control will&#160;<br/>be disabled.&#160;<br/>
<b>&#160;</b><br/>
&#160;<br/>
Requirement Id&#160;<br/>
link-time&#160;<br/>
C-<br/>
valid C-<br/>
A&#160;requirement id may be&#160;entered&#160;<br/>
identifie&#160;identifier&#160;<br/>
here for traceability reason.&#160;<br/>
r&#160;<br/>
Table 7-3&#160;&#160;&#160;User block description&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
75&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=76></a><img src="ElectricPowerSteering_TMS570_FIAT_321_website/content/en/docs/Fiasa_326_327_EPS_TMS570/HLDD/BSW/TechnicalReference_Asr_NvM-76_1.png"/><br/>
Technical Reference MICROSAR NVM&#160;<br/>
<b>7.2.5&#160;</b><br/>
<b>Error Detection&#160;</b><br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Error Detection – Development Mode&#160;<br/>
Development Error&#160;&#160;pre-compile&#160;--&#160;<br/>
ON&#160;<br/>
If activated then all checks – if&#160;<br/>
Detection&#160;<br/>
<b>OFF&#160;</b><br/>
enabled – will be done.&#160;Otherwise,&#160;<br/>no further development&#160;error&#160;<br/>detection will be done.&#160;<br/>
By setting this preprocessor&#160;<br/>switch to ON the general&#160;<br/>parameter checking is enabled.&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>In production mode,&#160;<br/>
&#160;&#160;this switch&#160;should be&#160;<br/>
disabled to&#160;save&#160;<br/>RAM/ROM and&#160;to&#160;<br/>speed up the module.<br/>
<b>&#160;</b><br/>
&#160;<br/>
Check Module’s&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate NVM initialization&#160;<br/>
Initialization Status&#160;<br/>
OFF&#160;<br/>
check within&#160;each&#160;API function call&#160;<br/>(except&#160;NvM_Init()&#160;and&#160;<br/>NvM_GetVersionInfo()).&#160;<br/>
Check Block’s&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate&#160;checking of&#160;block’s&#160;<br/>
Management Type&#160;<br/>
OFF&#160;<br/>
management type in&#160;API functions&#160;<br/>NvM_RestoreBlockDefaults(),&#160;<br/>
NvM_GetDataIndex()&#160;and&#160;<br/>NvM_SetDataIndex()&#160;<br/>respectively.&#160;<br/>
Check Block’s&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate&#160;checking of&#160;block’s&#160;<br/>
Write Protection&#160;<br/>
OFF&#160;<br/>
write protection and also&#160;the&#160;<br/>correct use&#160;of the write protection&#160;<br/>in&#160;API functions (write once):&#160;<br/>
NvM_WriteBlock(),&#160;<br/>NvM_InvalidateNvBlock(), &#160;<br/>NvM_EraseBlock() and&#160;<br/>NvM_SetBlockProtection().&#160;<br/>
Check Block’s&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate&#160;checking of&#160;block’s&#160;<br/>
Pending State&#160;<br/>
OFF&#160;<br/>
listed/pending state in all&#160;API&#160;<br/>functions, except&#160;<br/>NvM_GetErrorStatus(),&#160;<br/>
NvM_GetVersionInfo()&#160;and&#160;<br/>NvM_Init().&#160;<br/>
API Parameter&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
By setting this preprocessor&#160;<br/>
Checking&#160;<br/>
OFF&#160;<br/>
switch to ON the general&#160;<br/>parameter checking is enabled.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
76&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=77></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Check BlockId&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
ON&#160;<br/>
(De)Activate&#160;checking for block ID&#160;<br/>
<b>OFF&#160;</b><br/>
in correct range.&#160;<br/>
Check DataIndex&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate&#160;checking if&#160;DataIndex&#160;<br/>
OFF&#160;<br/>
passed to&#160;NvM_SetDataIndex()&#160;<br/>is in configured range.&#160;Applies&#160;<br/>only to management type&#160;Dataset.&#160;<br/>Relevant for the functions&#160;<br/>NvM_WriteBlock(),&#160;<br/>
NvM_InvalidateNvBlock()&#160;and&#160;<br/>
NvM_EraseBlock().&#160;<br/>
Check Pointers&#160;<br/>
pre-compile&#160;<br/>
--&#160;<br/>
<b>ON&#160;</b><br/>
(De)Activate&#160;checking if&#160;a pointer&#160;<br/>
OFF&#160;<br/>
parameter is not the&#160;NULL_PTR&#160;<br/>(NvM_GetDataIndex(),&#160;<br/>NvM_GetErrorStatus(),&#160;<br/>
NvM_GetVersionInfo()), or the&#160;<br/>
NULL_PTR&#160;was passed for a non-<br/>permanent block&#160;<br/>(NvM_ReadBlock(),&#160;<br/>NvM_WriteBlock(),&#160;<br/>
NvM_RestoreRomDefaults()).&#160;<br/>
Check RAM Block&#160;<br/>
link-time&#160;--&#160;<b>ON&#160;</b><br/>
(De)Activate&#160;RAM&#160;Block&#160;Length&#160;<br/>
Lengths&#160;<br/>
OFF&#160;<br/>
checks&#160;during initialization; see&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#16">chapter&#160;4.2.1&#160;</a><br/>
Check ROM Block&#160;&#160;link-time&#160;--&#160;<b>ON&#160;</b><br/>
(De)Activate&#160;ROM Block Length&#160;<br/>
Lengths&#160;<br/>
OFF<b>&#160;</b><br/>
checks&#160;during initialization; see&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#16">chapter&#160;4.2.1&#160;</a><br/>
Enable&#160;<br/>
pre-compile&#160;--&#160;<br/>
<b>ON&#160;</b><br/>
Enable/disable calls to&#160;DET.&#160;<br/>
Development Error&#160;<br/>
OFF&#160;<br/>
Nevertheless, the checks&#160;<br/>
Reporting&#160;<br/>
configured above will be&#160;<br/>performed, and&#160;API functions will&#160;<br/>return an appropriate value.&#160;<br/>
By setting this preprocessor&#160;<br/>switch to ON the following options&#160;<br/>have to be configured:&#160;<br/>
NVM_ERRORHOOK&#160;<br/>
NVM_CFG_INCLUDE_DET&#160;<br/>
Errorhook Function&#160;&#160;pre-compile&#160;<br/>
C-<br/>
Valid C-<br/>
Defines the&#160;function that&#160;is to be&#160;<br/>
function&#160;&#160;function&#160;<br/>
called in&#160;case of a Development&#160;<br/>
identifie&#160;identifier,&#160;<br/>
Error.&#160;<br/>
r&#160;<br/>
default:&#160;<br/>
<b>Det_Repor<br/>tError &#160;</b><br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
77&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=78></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default&#160;<br/>value is written&#160;<br/>in bold&#160;<br/>
Include File&#160;<br/>
pre-compile&#160;<br/>
header&#160;<br/>
Valid&#160;<br/>
Include this&#160;header to get the&#160;<br/>
file&#160;<br/>
header file,&#160;&#160;declaration of&#160;<br/>default:&#160;<br/>
Det_ReportError().&#160;<br/>
<b>Det.h&#160;</b><br/>
Error Detection – Production Mode&#160;<br/>
DEM Reporting&#160;<br/>
pre-compile&#160;C-<br/>
Valid C-<br/>
Name of the&#160;function to&#160;be called&#160;<br/>
Function&#160;<br/>
function&#160;&#160;function&#160;<br/>
when reporting an error. If an&#160;<br/>
identifie&#160;identifier,&#160;<br/>
AUTOSAR&#160;compliant DEM is&#160;<br/>
r&#160;<br/>
default:&#160;<br/>
used, it is named&#160;<br/>
<b>Dem_&#160;</b><br/>
Dem_ReportErrorStatus().&#160;<br/>
<b>ReportErr<br/>orStatus&#160;</b><br/>
Include File&#160;<br/>
pre-compile&#160;<br/>
header&#160;<br/>
Valid&#160;<br/>
Name of the&#160;header file&#160;publishing&#160;<br/>
file&#160;<br/>
header file,&#160;&#160;the DEM&#160;API, thus the error&#160;<br/>default:&#160;<br/>
function named above.&#160;If an&#160;<br/>
<b>Dem.h&#160;</b><br/>
AUTOSAR&#160;compliant DEM is&#160;<br/>used, it is named&#160;Dem.h.&#160;<br/>
Table&#160;7-4&#160;&#160;&#160;Error Detection&#160;<br/>
<b>7.2.6&#160;</b><br/>
<b>Module API&#160;</b><br/>
<b>7.2.6.1&#160;&#160;Provided API group&#160;</b><br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default value&#160;<br/>is written in bold&#160;<br/>
Provided&#160;API&#160;<br/>
--&#160;<br/>
--&#160;<br/>
--&#160;<br/>
This group shows the&#160;API&#160;<br/>services that were currently&#160;<br/>provided by&#160;the NVRAM&#160;<br/>Manager depending on its&#160;<br/>configuration.&#160;<br/>
Table 7-5&#160;&#160;&#160;Provided&#160;API&#160;<br/>
<b>7.3&#160;&#160;Attributes only&#160;configurable using GCE&#160;</b><br/>
The NVM contains parameters that can only&#160;be&#160;modified in GCE view; they are not visible&#160;<br/>in “Comfort View”, because it is&#160;not recommended to modify them. If those parameter’s&#160;<br/>differ from their default values (which are also recommended values) a warning will be&#160;<br/>issued during validation process.&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
78&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=79></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>Attribute Name&#160;</b><br/>
<b>Configuration&#160;&#160;Value&#160;</b><br/>
<b>Values&#160;</b><br/>
<b>Description&#160;</b><br/>
<b>Variant&#160;</b><br/>
<b>Type&#160;</b><br/>
The default value&#160;<br/>is written in bold&#160;<br/>
Nvm_30_CommonV&#160;pre-compile&#160;BOOL&#160;&#160;<b>TRUE</b>/FALS<br/>
Pre-Compile parameter,&#160;which&#160;<br/>
endorParams /&#160;<br/>
E&#160;<br/>
controls CRC(32) calculation. If&#160;<br/>
NvmCrcPreserveVal<br/>
enabled, the&#160;calculated result&#160;<br/>
ue&#160;<br/>
does not depend on setting of&#160;<br/>“CRC Bytes&#160;per Cycle”&#160;<br/>(NvmCrcNumOfBytes). See&#160;<br/>also chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#24">4.4.10&#160;</a><br/>
Nvm_30_CommonV&#160;link-time&#160;BOOL&#160;<br/>
<b>TRUE</b>/FALS<br/>
Link-Time parameter, which&#160;<br/>
endorParams /&#160;<br/>
E<b>&#160;</b><br/>
allows you to enable/disable&#160;<br/>
NvmCfgChkBlockLe<br/>
strict block length checks.&#160;<br/>
ngthStrict&#160;<br/>
<a href="TechnicalReference_Asr_NvMs.html#16">Refer to chapter&#160;4.2.1&#160;</a><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
79&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=80></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>8&#160;&#160;AUTOSAR Standard Compliance&#160;</b><br/>
<b>8.1&#160;&#160;Deviations&#160;</b><br/>
&#160;&#160;In contrast to&#160;AUTOSAR most configuration parameters are link-time parameters.&#160;<br/>
&#160;&#160;Saving&#160;RAM CRC of current block is configuration dependent. Either it is saved behind&#160;<br/>
the block’s data or it is saved internally by NVM in an own variable.&#160;<br/>
&#160;&#160;Unified handling of&#160;ROM defaults among all block management types is&#160;processed.&#160;<br/>
Rom defaults handling of blocks of type dataset&#160;is just like the handling of blocks of the&#160;<br/>other management types.&#160;<br/>
&#160;&#160;NVM is able to provide the Config Id’s RAM block on its own.&#160;<br/>
&#160;&#160;NvM_WriteAll() does not write unchanged data, even if this would repair (redundant) NV&#160;<br/>
data.&#160;<br/>
&#160;&#160;NVM provides an additional customer specific&#160;API&#160;NvM_SetBlockLockStatus() for&#160;<br/>
setting/resetting a lock for a NV block. (see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#45">6.4.8)&#160;</a><br/>
<b>8.2&#160;&#160;Additions/ Extensions&#160;</b><br/>
<b>8.2.1&#160;</b><br/>
<b>Parameter Checking&#160;</b><br/>
The internal parameter checks of the&#160;API functions can be en-/disabled separately.&#160;The&#160;<br/>AUTOSAR standard requires en-/disabling of the&#160;complete parameter checking only. For&#160;<br/>details see chapter&#160;<a href="TechnicalReference_Asr_NvMs.html#28">4.5.1.1</a>.&#160;<br/>
<b>8.2.2&#160;</b><br/>
<b>Concurrent&#160;access to NV data&#160;</b><br/>
NVM provides for DCM possibility to access NV&#160;data concurrently with NVM’s applications.&#160;<br/><a href="TechnicalReference_Asr_NvMs.html#26">(see chapter&#160;4.4.17</a>)&#160;<br/>
<b>8.2.3&#160;</b><br/>
<b>RAM-/ROM Block Size checks&#160;</b><br/>
NVM can be configured to check all RAM and&#160;ROM blocks’&#160;lengths against corresponding&#160;<br/>NV Block lengths, using&#160;sizeof<a href="TechnicalReference_Asr_NvMs.html#16">&#160;operator; see chapter&#160;4.2.1</a>.&#160;<br/>
<b>8.2.4&#160;</b><br/>
<b>Calculated CRC value&#160;does not depend on number of calculation steps&#160;</b><br/>
Due to the specified CRC32 algorithm, and&#160;missing further requirements on NVM’s&#160;CRC&#160;<br/>calculation,&#160;a calculated CRC32 value depends&#160;on the number of necessary calculation&#160;<br/>steps (defined by block length and parameter “CRC Bytes per Cycle”). Unless the CRC&#160;<br/>can be calculated with one step (i.e. the block is small enough), the&#160;CRC32 value will not&#160;<br/>match the value resulting from&#160;calling the CRC32 library function once for the whole block.&#160;<br/>
The reason&#160;is the&#160;negation of the&#160;result, as&#160;specified&#160;for CRC32 (which&#160;in&#160;turn belongs to&#160;<br/>standard/widely used&#160;“Ethernet CRC”).&#160;This&#160;behavior introduces some drawbacks&#160;on&#160;<br/>NVM, especially: &#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
80&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=81></a>Technical Reference MICROSAR NVM&#160;<br/>
&#160;&#160;Changing&#160;parameter “CRC Bytes per Cycle” (for&#160;run-time optimization), in an existing&#160;<br/>
(already flashed) project. Data&#160;blocks with CRC32 could not be read after the update.&#160;<br/>
&#160;&#160;CRC32 values cannot be verified outside NVM&#160;(e.g. for testing purposes), without&#160;<br/>
knowing the configuration – each single step would have to be reproduced.&#160;<br/>
&#160;&#160;Valid data blocks along with&#160;their CRC32 cannot be pre-defined using&#160;standard CRC&#160;<br/>
algorithms.&#160;<br/>
NVM circumvents these restrictions by reverting the final negation&#160;of each single CRC32&#160;<br/>calculation step, except&#160;the last one.&#160;This (quite simple) measure guarantees that the CRC&#160;<br/>value does&#160;not&#160;depend on the number of calculation steps,&#160;as it is originally guaranteed for&#160;<br/>CRC16 (since it will not be inverted by the CRC library).&#160;<br/>
<b>8.3&#160;&#160;Limitations&#160;</b><br/>
There are no limitations.&#160;<br/>
&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
81&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=82></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>9&#160;&#160;Glossary and&#160;Abbreviations&#160;</b><br/>
<b>9.1&#160;&#160;Glossary&#160;</b><br/>
<b>Term&#160;</b><br/>
<b>Description&#160;</b><br/>
DaVinci Configurator&#160;&#160;Configuration and generation tool for&#160;MICROSAR.&#160;<br/>Pro&#160;<br/>
DCM&#160;Diagnostic&#160;<br/>
Communication&#160;<br/>
Manager&#160;<br/>
GCE&#160;<br/>
Generic Configuration&#160;Editor – generic tool for&#160;editing&#160;AUTOSAR&#160;<br/>configuration files.&#160;<br/>
In DaVinci Configurator, the view can be switch to&#160;“Generic Editor”.&#160;<br/>
PIM&#160;<br/>
Per Instance Memory&#160;<br/>
Table 9-1&#160;&#160;&#160;Glossary&#160;<br/>
&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
82&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=83></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>9.2&#160;&#160;Abbreviations&#160;</b><br/>
<b>Abbreviation&#160;</b><br/>
<b>Description&#160;</b><br/>
API&#160;Application&#160;<br/>
Programming&#160;<br/>
Interface&#160;<br/>
&#160;<br/>
AUTOSAR&#160;Automotive&#160;<br/>
Open&#160;<br/>
System&#160;<br/>
Architecture&#160;<br/>
BSW&#160;Basis&#160;<br/>
Software&#160;<br/>
CRC&#160;<br/>
Cyclic Redundancy Check&#160;<br/>
DEM&#160;Diagnostic&#160;<br/>
Event&#160;<br/>
Manager&#160;<br/>
DET&#160;Development&#160;<br/>
Error&#160;<br/>
Tracer&#160;<br/>
EA&#160;EEPROM&#160;<br/>
Abstraction&#160;<br/>
Module&#160;<br/>
ECU&#160;<br/>
Electronic Control Unit&#160;<br/>
ECUM&#160;<br/>
ECU State Manager&#160;<br/>
EEP&#160;EEPROM&#160;<br/>
Driver&#160;<br/>
EEPROM&#160;<br/>
Electrically Erasable Programmable&#160;Read Only&#160;Memory&#160;<br/>
FEE&#160;<br/>
Flash EEPROM&#160;Emulation Module&#160;<br/>
FIFO&#160;<br/>
First In First&#160;Out&#160;<br/>
FLS&#160;Flash&#160;<br/>
Driver&#160;<br/>
GCE&#160;Generic&#160;<br/>
Configuration&#160;<br/>
Editor&#160;<br/>
HIS&#160;<br/>
Hersteller Initiative Software&#160;<br/>
ISR&#160;<br/>
Interrupt Service Routine&#160;<br/>
MemHwA&#160;<br/>
Memory Hardware&#160;Abstraction Layer&#160;<br/>
MEMIF&#160;<br/>
Memory&#160;Abstraction Interface Module&#160;<br/>
MICROSAR&#160;<br/>
Microcontroller Open System&#160;Architecture (the Vector&#160;AUTOSAR&#160;<br/>solution)&#160;<br/>
NVM&#160;NVRAM&#160;<br/>
Manager&#160;<br/>
NV, NVRAM&#160;<br/>
Non Volatile&#160;Random&#160;Access Memory&#160;<br/>
OS&#160;Operating&#160;<br/>
System&#160;<br/>
PPort&#160;Provide&#160;<br/>
Port&#160;<br/>
RAM&#160;Random&#160;<br/>
Access&#160;<br/>
Memory&#160;<br/>
ROM&#160;Read&#160;<br/>
Only&#160;<br/>
Memory&#160;<br/>
RPort&#160;Require&#160;<br/>
Port&#160;<br/>
RTE&#160;Runtime&#160;<br/>
Environment&#160;<br/>
SRS&#160;<br/>
Software Requirement Specification&#160;<br/>
SWC&#160;Software&#160;<br/>
Component&#160;<br/>
SWS&#160;Software&#160;<br/>
Specification&#160;<br/>
Table 9-2&#160;&#160;&#160;Abbreviations&#160;<br/>
&#160;<br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
83&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name=84></a>Technical Reference MICROSAR NVM&#160;<br/>
<b>10&#160;&#160;Contact&#160;</b><br/>
Visit our website for more information on&#160;<br/>&#160;<br/>&gt;&#160; &#160;News&#160;<br/>&gt;&#160; &#160;Products&#160;<br/>&gt;&#160; &#160;Demo software&#160;<br/>&gt;&#160; &#160;Support&#160;<br/>&gt;&#160; &#160;Training data&#160;<br/>&gt;&#160; &#160;Addresses&#160;<br/>&#160;<br/>
<a href="http://www.vector-informatik.com/"><b>www.vector-informatik.com&#160;</b></a><br/>
&#160;<br/>
©2011, Vector Informatik GmbH&#160;<br/>
Version: 3.07.00&#160;<br/>
84&#160;/ 84<br/>
based on template&#160;version 3.01&#160;<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#2">1 Document Information</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#2">1.1 History</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#4">1.2 Reference Documents</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#11">2 Component History</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#12">3 Introduction</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#13">3.1 Architecture Overview</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#15">4 Functional Description</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#15">4.1 Features</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#15">4.2 Initialization</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#16">4.2.1 Block Size Checks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#17">4.2.2 Start-up</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#17">4.2.3 Initialization of the Data Blocks</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#18">4.3 States</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#18">4.4 Main Functions</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#18">4.4.1 Hardware Independence</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#18">4.4.2 Synchronous Requests</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#18">4.4.3 Asynchronous Requests</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#19">4.4.4 API Configuration Classes and additional API Services</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#20">4.4.5 Block Handling</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#20">4.4.5.1 NV Blocks and Block Handles</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#21">4.4.5.2 Different Types of NV Blocks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#22">4.4.5.3 Permanent and non-permanent RAM Blocks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#23">4.4.5.4 ROM Defaults</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#23">4.4.5.5 Checksum</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#23">4.4.6 Prioritized or non-prioritized Queuing of asynchronous Requests</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#23">4.4.7 Asynchronous Job-End Polling</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#23">4.4.8 Asynchronous Job-End Notification</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#24">4.4.9 Immediate Priority Jobs and Cancellation of current Jobs</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#24">4.4.10 Asynchronous CRC Calculation</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#25">4.4.11 Write Protection</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#25">4.4.12 Erase and Invalidate</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#25">4.4.13 Init Callbacks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#25">4.4.14 Define Locking/ Unlocking Services</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#26">4.4.15 Interrupts</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#26">4.4.16 Data Corruption</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#26">4.4.17 Concurrent access to NV data for DCM</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#26">4.4.18 Removed Functionality</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#27">4.4.19 Changed Functionality</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#27">4.5 Error Handling</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#27">4.5.1 Development Error Reporting</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#28">4.5.1.1 Parameter Checking</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#29">4.5.2 Production Code Error Reporting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#31">5 Integration</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#31">5.1 Scope of Delivery</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#31">5.1.1 Static Files</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#32">5.1.2 Dynamic Files</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#32">5.2 Include Structure</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#33">5.3 Compiler Abstraction and Memory Mapping&#160;</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4 Dependencies on SW Modules</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.1 OSEK / AUTOSAR OS</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.2 DEM</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.3 DET</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.4 MEMIF</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.5 CRC Library</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#34">5.4.6 Callback Functions</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#35">5.4.7 RTE</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#35">5.5 Integration Steps</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#35">5.6 Estimating Resource Consumption</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#36">5.6.1 RAM Usage</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#36">5.6.2 ROM Usage</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#36">5.6.3 NV Usage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#38">6 API Description</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#38">6.1 Interfaces Overview</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#38">6.2 Type Definitions</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#40">6.3 Global API Constants</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#40">6.4 Services provided by NVM</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#40">6.4.1 NvM_Init</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#41">6.4.2 NvM_SetDataIndex</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#41">6.4.3 NvM_GetDataIndex</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#42">6.4.4 NvM_SetBlockProtection</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#43">6.4.5 NvM_GetErrorStatus</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#43">6.4.6 NvM_GetVersionInfo</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#44">6.4.7 NvM_SetRamBlockStatus</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#45">6.4.8 NvM_SetBlockLockStatus</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#46">6.4.9 NvM_MainFunction</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#46">6.4.10 NvM_ReadBlock</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#47">6.4.11 NvM_WriteBlock</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#48">6.4.12 NvM_RestoreBlockDefaults</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#49">6.4.13 NvM_EraseNvBlock</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#50">6.4.14 NvM_InvalidateNvBlock</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#51">6.4.15 NvM_ReadAll</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#52">6.4.16 NvM_WriteAll</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#52">6.4.17 NvM_CancelWriteAll</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#53">6.4.18 NvM_KillWriteAll</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#53">6.5 Services used by NVM</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#54">6.6 Callback Functions</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#54">6.6.1 NvM_JobEndNotification</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#55">6.6.2 NvM_JobErrorNotification</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#55">6.7 Configurable Interfaces</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#55">6.7.1 &#160;SingleBlockCallbackFunction</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#56">6.7.2 MultiBlockCallbackFunction&#160;</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#56">6.7.3 InitBlockCallbackFunction</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#57">6.8 Service Ports</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#57">6.8.1 Client Server Interface</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1 Provide Ports on NVM side</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1.1 PAdmin_&lt;BlockName&gt;</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#57">6.8.1.1.2 PS_&lt;BlockName&gt;</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#58">6.8.1.2 Require Ports</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#58">6.8.1.2.1 NvM_RpNotifyFinished_Id&lt;BlockName&gt;</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#59">7 Configuration</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#59">7.1 Software Component Template</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#59">7.1.1 Generation</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#61">7.1.2 Import into DaVinci Developer</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#62">7.1.3 Dependencies on Configuration of NVM Attributes</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#62">7.1.3.1 Naming of Service Port Interfaces</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#62">7.1.4 Service Port Prototypes</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#63">7.1.4.1 Port Prototype Naming</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#63">7.2 Configuration of NVM Attributes</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#64">7.2.1 Start configuration of the NVM</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#65">7.2.2 General Settings</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#67">7.2.3 Special NVRAM Blocks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#69">7.2.4 User Block Description</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#76">7.2.5 Error Detection</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#78">7.2.6 Module API</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#78">7.2.6.1 Provided API group</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#78">7.3 Attributes only configurable using GCE</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8 AUTOSAR Standard Compliance</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.1 Deviations</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.2 Additions/ Extensions</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.2.1 Parameter Checking</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.2.2 Concurrent access to NV data</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.2.3 RAM-/ROM Block Size checks</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#80">8.2.4 Calculated CRC value does not depend on number of calculation steps</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#81">8.3 Limitations</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#82">9 Glossary and Abbreviations</a>
<ul>
<li><a href="TechnicalReference_Asr_NvMs.html#82">9.1 Glossary</a></li>
<li><a href="TechnicalReference_Asr_NvMs.html#83">9.2 Abbreviations</a></li>
</ul>
</li>
<li><a href="TechnicalReference_Asr_NvMs.html#84">10 Contact</a></li>
</ul>
<hr/>
</body>
</html>
